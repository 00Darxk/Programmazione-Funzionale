\documentclass{article}

\usepackage{cancel}
\usepackage{amsmath,amssymb}
\usepackage[includehead,nomarginpar]{geometry}
\usepackage{graphicx} \usepackage{amsfonts} 
\usepackage{verbatim}
\usepackage{mathrsfs}  
\usepackage{lmodern}
\usepackage{braket}
\usepackage{bookmark}
\usepackage{fancyhdr}
\usepackage{romanbarpagenumber}
\usepackage{minted}
%\usepackage{subfig}
\usepackage[italian]{babel}
\usepackage{float}
%\usepackage{wrapfig}
%\usepackage[export]{adjustbox}
\usepackage{contour}
\usepackage[normalem]{ulem}
\allowdisplaybreaks

\setlength{\headheight}{12.0pt}
\addtolength{\topmargin}{-12.0pt}
\graphicspath{ {./Immagini/} }

\hypersetup{
    colorlinks=true,
    linkcolor=black,
    pdftitle={Appunti di Programmazione Funzionale},
    pdfauthor={Giacomo Sturm},
    pdfsubject={Programmazione Funzionale, OCaml, ML},
    pdfkeywords={Programmazione Funzionale, OCaml, ML}
}

\newsavebox{\tempbox} %{\raisebox{\dimexpr.5\ht\tempbox-.5\height\relax}}


\makeatother
\renewcommand{\contentsname}{Indice}
\numberwithin{equation}{subsection}
\newcommand{\tageq}{\tag{\stepcounter{equation}\theequation}}
\AtBeginDocument{%
    \renewcommand{\figurename}{Fig.}
}
\renewcommand{\ULdepth}{1.8pt}
\contourlength{0.6pt}
\newcommand{\myuline}[1]{%
    \uline{\phantom{#1}}%
    \llap{\contour{white}{#1}}%
}
\fancypagestyle{link}{\fancyhf{}\renewcommand{\headrulewidth}{0pt}\fancyfoot[C]{Sorgente del file \LaTeX disponibile al seguente link: \url{https://github.com/00Darxk/Programmazione-Funzionale/}}}

\begin{document}

\title{%
    \textbf{Programmazione Funzionale}  \\ 
    \large Appunti delle Lezioni di Programmazione Funzionale \\
    \textit{Anno Accademico: 2024/25}}
\author{\textit{Giacomo Sturm}}
\date{\textit{Dipartimento di Ingegneria Civile, Informatica e delle Tecnologie Aeronautiche \\
Università degli Studi ``Roma Tre"}}

\maketitle
\thispagestyle{link}

\clearpage


\pagestyle{fancy}
\fancyhead{}\fancyfoot{}
\fancyhead[C]{\textit{Programmazione Funzionale - Università degli Studi ``Roma Tre"}}
\fancyfoot[C]{\thepage}
\pagenumbering{Roman}

\tableofcontents

\clearpage
\pagenumbering{arabic}

%% 2 esoneri uno aprile uno a maggio, orale 

\section{Introduzione ad OCaml}

La programmazione funzionale è un paradigma di programmazione estremamente potente, utilizza un metodo completamente diverso dagli altri paradigmi di programmazione. L'idea di base consiste nel considerare un programma una funzione, è un linguaggio di alto livello dichiarativo. Il programmatore infatti specifica che cosa deve essere calcolato, non come deve essere calcolato, a differenza di linguaggi imperativi.  
Il linguaggio di programmazione pià funzionale è Haskell, nel corso verrà usato il linguaggio Objective Caml, contiene aspetti di programmazione orientata agli oggetti. 
%% ?? un po' bastardo
Objective Caml appartiene alla famiglia \textit{Meta Language} ML sviluppata dall'INRIA in Francia dal 1984. 
Dietro un linguaggio c'è un modello di calcolo che determina le operazioni eseguibili ed anche lo stile di programmazione. 
Si basa sul lambda calcolo, un linguaggio Turing completo, estremamente semplice. 

I tre costrutti fondamentali sono applicazioni, composizione e ricorsione. Su alcune distribuzioni di Linux l'interprete OCaml è preinstallato, ed è possibile interagirci digitando il comando \verb|ocaml| su un terminale:
\begin{minted}{ocaml}
    prompt> ocaml
    OCaml version x.x.x
    Enter #help;; for help.

    #
\end{minted}

Nella modalità interattiva il compilatore effettua il ciclo read-eval-print, legge un'espressione o una dichiarazione, terminata dalla sequenza \verb|;;|, in seguito calcola il valore, deducendo i tipi delle variabili utilizzate, e restituisce la soluzione a schermo. 
Non c'è bisogno di dichiarazioni esplicite, OCaml può effettuare inferenze di tipo anche su espressioni estremamente complesse. È un linguaggio a tipizzazione statica, ogni tipo può essere determinato a tempo di compilazione. I tipi base di OCaml sono \verb|bool|, \verb|int|, \verb|float|, \verb|string|, \verb|char|, \verb|unit| e \verb|exn|. 

\subsection{Dichiarazioni e Funzioni}

I costrutti di base sono le espressioni, non sono comandi, hanno sempre un valore ed un tipo. Il calcolo procede valutando queste espressioni, semplificandole fino ad ottenere un'espressione non più semplificabile, cioè un valore. I costruttori di controllo principale sono applicazione e composizione di funzioni e ricorsione. 

La forma generale di una dichiarazione consiste dalla parola chiave \verb|let| seguita dall'identificatore, a cui si assegna una certa espressione:
\begin{minted}{ocaml}
    let <identificatore> <parametri> = <espressione>
\end{minted}

Per specificare gli argomenti o parametri di una funzione, bisogna specificarli dopo il nome della funzione, per indicare che si tratta di una funzione ricorsiva bisogna utilizzare la parola chiave \verb|rec|, dopo \verb|let|:
\begin{minted}{ocaml}
    let rec <identificatore> <parametri> = <espressione>
\end{minted}

Le espressioni funzionali sono un particolare costrutto di espressioni introdotto dalla parola chiave \verb|function|:
\begin{minted}{ocaml}
    function <parametri> -> <espressione>
\end{minted}
Sono praticamente una funzione anonima, possono essere combinate con una dichiarazione con identificatore, avendo anch'essa un valore, per essere utilizzata all'interno della sua espressione. 

Un ambiente è una collezione di legami tra variabili e valori, l'ambiente iniziale comprende tutte queste associazioni presenti nel modulo iniziale contenuto in \verb|Stdlib|. 
Quando viene aggiunta una nuova dichiarazione viene aggiunto un nuovo legame in cima a questo ambiente. Questo ambiente viene gestito come una pila, quindi dichiarazioni future sovrascrivono dichiarazioni precedenti, poiché vengono accedute prima. 
Il valore delle variabili globali viene determinato a tempo di compilazione. Per cui è possibile modificare il valore di una variabile globale sovrascrivendola, ma altri oggetti possono comunque riferirsi alla vecchia definizione di questi valori, poiché si riferisce al tempo dove questa dichiarazione è stata inserita nell'ambiente:
\begin{minted}[escapeinside=||, mathescape]{ocaml}
    # let one = 1;;
    val one : int =  1
    # let oneplus n = n + one;;
    val oneplus : int |$\rightarrow$| int = <fun>
    # let one = 2;;
    val one = 2
    # oneplus 1;;
    - : int = 2
\end{minted}
\begin{center}
    \begin{tabular}{|c|c|}
        \hline Variabile & Valore\\\hline
        \texttt{one} & 2 \\\hline
        \texttt{oneplus} & \texttt{function n} $\to$ \texttt{n + one} \\\hline
        \texttt{one} & 1 \\\hline
        \multicolumn{2}{|c|}{\texttt{StdLib}}\\\hline
    \end{tabular}
\end{center}
Nel corpo di \texttt{oneplus} il valore di \texttt{one} viene cercato nel suo ambiente di dichiarazione, nell'ambiente dove è stata definita la funzione \texttt{oneplus}. Questo ambiente è costituito da tutti i legami precedenti nella pila. 
Quando viene applicato un argomento ad una funzione, il suo argomento viene valutato nell'ambiente, viene creato un legame provvisorio del parametro formale con il valore dell'argomento. In questo nuovo ambiente viene valutato il corpo della funzione. Dopo aver determinato il valore della funzione viene eliminato il legame provvisorio. 

Quando si effettua una definizione che non dipende dal tipo specificato dei suoi parametri, queste vengono sostituite da variabili di tipo \verb|'a|, che rappresentano un tipo generico. Per indicare che si tratta di un tipo generico viene preceduto da un'apostrofo, convenzionalmente si usano le lettere greche, $\alpha$ in questo caso. Le funzioni così dichiarate si possono applicare a parametri di qualunque tipo. 

Le funzioni sono oggetti di prima classe, hanno un proprio valore ed un tipo, quindi è possibile manipolarli, passando funzioni come argomenti ad altre funzioni. 

Nelle espressioni di tipo si associa a destra:
\begin{minted}[escapeinside=||, mathescape]{ocaml}
    int |$\rightarrow$| int |$\rightarrow$| int = int |$\rightarrow$| (int |$\rightarrow$| int)
\end{minted}
Mentre nelle espressioni si associa a sinistra:
\begin{minted}{ocaml}
    (func n) m = func n m
\end{minted}
Per cui l'uso delle parentesi è essenziale per il buon funzionamento del codice. 

Le funzioni sono oggetti di prima classe, funzioni di ordine superiore sono dei costrutti che prendono come argomento o riportano come valore una funzione. 
Funzioni possono essere componenti di una struttura dati, argomenti di altre funzioni o possono essere valori restituiti da altre funzioni. 


In questo modo si possono realizzare semplicemente funzioni come la sommatoria, che prendono come argomento la funzione \verb|f| di cui devono effettuare la somma:
\begin{minted}[escapeinside=||, mathescape]{ocaml}
    # let rec sum f (lower, upper) =
        if lower > upper then 0
        else f lower + sum f (lower + 1, upper)
    val sum : (int |$\rightarrow$| int) |$\rightarrow$| int * int |$\rightarrow$| int = <fun>
\end{minted}

La funzione \verb|sum| può essere applicata anche soltanto al suo primo argomento, generando una funzione di prima classe. Invece di inserire una coppia si possono inserire due elementi, \textit{currificando} la funzione, ovvero può funzionare anche con valutazione parziale, generando una funzione che si aspetta i rimanenti parametri, invece di generare un errore. Una funzione in forma currificata calcola gli stessi valori, consumando un solo argomento alla volta:
\begin{minted}[escapeinside=||, mathescape]{ocaml}
    # let rec sum f lower upper =
        if lower > upper then 0
        else f lower + sum f (lower + 1) upper;;
    val sum : (int |$\rightarrow$| int) |$\rightarrow$| int |$\rightarrow$| int |$\rightarrow$| int = <fun>
\end{minted}

Una funzione non currificata non può essere applicata parzialmente. 
In generale $f_c$ è la forma currificata di $f$ se:
\begin{gather*}
    f:\,t_1\times\cdots\times t_n\rightarrow t\\
    f_c:\,t_1\rightarrow(t_2\rightarrow\cdots\rightarrow(t_n\rightarrow t)\cdots)
\end{gather*}
Currificando una funzione è possibile applicarla parzialmente. 

Molte operazioni predefinite in OCaml sono in forma currificata. Le operazioni infisse predefinite sono in forma currificata, per utilizzarla in forma infissa si racchiude tra due parentesi tonde \verb|(...)|. Per definire degli operatori infissi si racchiudono tra parentesi nella loro definizione: \verb|let (...) = ...|. Questi operatori possono essere usati in forma infissa e specificando dopo gli argomenti oppure tra se prende due argomenti tra questi senza parentesi:
\begin{minted}[mathescape=true, escapeinside=||]{ocaml}
    # let (++) x y = 2 * (x + y);;
    val (++) : int |$\rightarrow$| int |$\rightarrow$| int = <fun>
    # (++) 3 5;;
    - : int 16
    # 3 ++ 5
    - : int 16
\end{minted}

Per effettuare un'operazione di composizione il codominio della seconda funzione deve essere uguale al dominio della prima funzione. Restituisce una funzione $f$ applicata su $g$: $f\circ g$, si utilizza la parola chiave \verb|comp|:
\begin{minted}{ocaml}
    let comp f g x = f (g x)
\end{minted}
La composizione è definita come un'operatore infisso \verb|(@@)|. 

\subsection{Tipi}

Un tipo è l'insieme dei valori che può assumere, i tipi predefiniti sono:
\begin{itemize}
    \item Booleani: \verb|{true, false}|, su cui sono definite le operazioni booleane \verb|not|, \verb|&&| e \texttt{||}. 
    \item Interi: \verb|{min_int,...,-1,0,1,...,max_int}|, su cui sono definite le operazioni \verb|+|, \verb|-|, \verb|*|, \verb|/|, \verb|mod|, \verb|succ| e \verb|pred|.
    \item Numeri reali a virgola mobile \verb|float|, su cui sono definite alcune delle stesse funzioni definite sugli interi, ma per mantenere l'inferenza di tipo vengono seguiti da un punto: \verb|+.|, \verb|-.|, \verb|*.| e \verb|/.|. Oltre a queste sono definite le più importanti funzioni matematiche sui reali. Non è presente la conversione automatica dei tipi numerici. 
    \item Caratteri \verb|char|, definiti sempre tra due apici \verb|'...'|, si possono convertire in codice ASCII corrispondente e viceversa con \verb|int_of_char| e \verb|char_of_int|. 
    \item Stringhe tra doppi apici \verb|"..."|, che possono essere concatenate con l'operatore di concatenazione \verb|^|, si può accedere ai singoli caratteri con la notazione puntata specificando la posizione \verb|.[i]|, la funzione \verb|string_of_int| converte un numero intero in una stringa. 
\end{itemize} 
Il tipo \verb|unit| ha un unico elemento \verb|()| e può essere usato al posto di qualsiasi tipo, si comporta come un super-tipo per tutti i tipi semplici.  

Se si utilizzano funzioni definite su interi su reali o viceversa, viene generato un errore, sono comunque presenti funzioni per convertire tra questi tipi, ma operazioni di casting vengono sconsigliate. 
Gli operatori di confronto \verb|<|, \verb|>| e \verb|=| sono definiti su qualsiasi tipo, eccetto che sulle funzioni. Nella notazione di OCaml il non uguale si rappresenta come \verb|<>|. Si possono effettuare confronti tra tuple, controllando secondo l'ordine lessicografico partendo dalla prima componente. 

\subsection{Espressioni Condizionali}

Si possono realizzare istruzioni condizionali con il costrutto \verb|if E then F else G|, dove \verb|E| è un booleano, mentre \verb|F| e \verb|G| sono espressioni dello stesso tipo o almeno un sottotipo in comune, e nei linguaggi ML deve essere possibile determinarlo a tempo di compilazione, essendo linguaggi fortemente tipati. 

Non è un costrutto di controllo come nei linguaggi imperativi, ma è un'espressione con un valore ed un tipo, il più generale tra \verb|F| e \verb|G|. Viene valutata in maniera pigra, se \verb|E| è vera, non viene valutata \verb|G|, mentre se è falsa non viene valutata \verb|F|. 

Le seguenti espressioni sono quindi equivalenti:
\begin{itemize}
    \item \verb|E && F|: \verb|if E then F else false|.
    \item \texttt{E || F}: \verb|if E then true else F|.
\end{itemize}
Il costrutto \verb|else| viene sempre indentato sotto i rispettivi \verb|if|, e deve essere presente la parte \verb|else|, non è presente ambiguità. 


Per valutare le espressioni in linguaggi ML si utilizza la regola di calcolo \textit{call by value}, la valutazione per valore, dove si calcola il valore dell'argomento prima di applicare la funzione, invece della valutazione per nome \textit{call by name}, questa regola viene utilizzata solamente nelle espressioni condizionali ed operatori booleani. La regola di calcolo per nome applica la funzione prima di aver calcolato il valore dell'argomento. 
Se non si valutassero le espressioni booleane in modo pigro, ogni funzione ricorsiva che utilizza una funzione booleana per effettuare la ricorsione, valuterebbe all'infinito il passo ricorsivo, senza poter mai fermarsi. 

\subsection{Coppie}

Le coppie ordinate sono formate da due elementi divisi da una virgola tra parentesi tonde: \verb|(E, F)|. Per rappresentare un costrutto di tipo si utilizza l'operatore \verb|*| per indicarlo, il prodotto cartesiano non è associativo. Una tupla di tuple è diversa da una tripla: \verb|int * (int * int)| \verb|<>| \verb|int * int * int|. 
Sulle coppie si utilizzano le funzioni \verb|fst| e \verb|snd| per restituire il primo ed il secondo elemento della coppia, queste sono polimorfe, ma se vengono usate su tuple di più di due elementi restituiscono un errore. 

Le coppie come tutti i tipi di dati su OCaml sono definiti da un insieme di costruttori che creano valori di quel tipo, ed un insieme di selettori, operazioni per selezionare componenti da un valore di tipo. 
I tipi semplici non hanno selettori, ma solo costruttori, questi sono tutti i valori del tipo. 
Per le coppie il costruttore è \verb|(,)|, l'insieme tra parentesi e virgola, applicato ad un'espressione di tipo $\alpha$ e $\beta$. Mentre i selettori sono \verb|fst| e \verb|snd|. 



\clearpage

\section{Ricorsione e Pattern}

\subsection{Definizioni Ricorsive}

Nei linguaggi funzionali non esistono costrutti di controllo, ma il principale meccanismo di controllo è la ricorsione, realizzato tramite la parola chiave \verb|rec|. 
In linguaggi funzionali ``puri'', non sono presenti costrutti di controllo per realizzare cicli. Per risolvere un problema ricorsivamente bisogna identificare i casi base, che possono essere risolti immediatamente. Inoltre bisogna identificare sotto-problemi più semplici di un generico problema complesso, che possono aiutare ad individuare la sua soluzione. Supponendo di poter risolvere questi problemi, l'ipotesi di lavoro, bisogna operare sulla soluzione di questi sotto-problemi per ottenere la soluzione del problema complesso. 

\subsubsection{Esempio: \texttt{split\_string}}

Si considera il problema di valutare un'espressione aritmetica rappresentata in una stringa. L'operazione è tra due interi non negativi, la funzione offerta come soluzione dovrebbe riportare il risultato di questa espressione. Le operazioni consentite sono la somma, differenza, prodotto e divisione intera. 
Si avrà una funzione: \verb|evaluate: string -> int|. Applicata su una variabile $s$, di tipo stringa deve restituire il risultato dell'espressione rappresentata, o un errore se non rispetta le condizioni d'uso. 

Un sotto-problema utile consiste nel suddividere la stringa in tre parti, i due interi operandi ed il carattere che identifica l'operatore: \verb|split_string: string| $\rightarrow$ \verb|int * char * int|. Applicata ad una stringa $s$ restituisce una tripla $(n,op,m)$. 

Per risolvere questo problema bisogna individuare quale dei caratteri della stringa non è un numero, si può effettuare con un'altra funzione \verb|primo_non_numerico: string| $\rightarrow$ \verb|int|. Data una stringa $s$ passata come input restituisce la posizione $i$-esima del primo carattere non numerico nella stringa. 

Si può definire inoltre un'altra funzione per tagliare una porzione della stringa tra due posizioni fornite \verb|substring: string| $\rightarrow$ \verb|int| $\rightarrow$ \verb|int| $\rightarrow$ \verb|string|. Applicata ad una stringa $s$, restituisce la sotto-stringa dalla posizione $j$-esima alla posizione $k$-esima. 

Dal moduli Pervasives si può usare la funzione \verb|int_of_string| per restituire l'intero corrispondente ad una stringa. Dal modulo String, si possono usare la funzione \verb|sub| e \verb|length| per restituire una sotto-stringa la prima e la lunghezza di una stringa la seconda. 
Queste funzioni producono un errore se la stringa non corrisponde ad un intero la prima, ovvero se sono presenti caratteri non numerici, e se gli indici forniti non appartengono alla stringa, la seconda. 

Per controllare i caratteri di una stringa si usa la funzione \verb|get| del modulo String, abbreviata in notazione puntata come \verb|.[i]|. Si definisce quindi la funzione per trovare il primo carattere non numerico:
\begin{minted}{ocaml}
    let rec loop s i = 
        if (s.[i] < '0' || s.[i] > '9') then i
        else loop s (i + 1);;
    let primo_non_numerico s = loop s 0;;
\end{minted}
% primo_non_numerico "111a";;

\subsection{Dichiarazioni Locali}

All'interno di una funzione si possono dichiarare ulteriori espressioni, con il costrutto \verb|let...in|, dove si dichiara l'espressione normalmente con \verb|let|, seguito da \verb|in|, dove vengono passati i parametri da applicare all'espressione locale. Le variabili definite nella dichiarazione locale sono variabili locali, inizializzate nel \verb|in|, queste hanno un valore solamente all'interno dell'espressione locale. Quando viene valutata la funzione, questa variabile non ha più valore, viene quindi creato un legame temporanea nell'ambiente quando viene invocata quest'espressione locale tramite l'\verb|in|. All'interno di una funzione locale, sono visibili i parametri globali della funzione esterna, e possono essere usati e modificati all'interno di espressioni locali. 

Data una dichiarazione locale \verb|let x = E in F| in un ambiente $\mathscr{A}$, viene calcolato il valore \verb|v| della dichiarazione \verb|E| di \verb|let|, e viene provvisoriamente legata alla variabile \verb|x| estendendo $\mathscr{A}$. In questo nuovo ambiente viene calcolato il valore dell'espressione \verb|F| di \verb|in|. Il valore così calcolato di \verb|F| diventa il valore dell'intera espressione. Dopo averlo calcolato viene sciolto il legame provvisorio di \verb|x|, e viene ripristinato l'ambiente $\mathscr{A}$. Un'espressione locale è quindi equivalente a: \verb|let x = E in F| $\Leftrightarrow$ \verb|(function x| $\rightarrow$ \verb|F) E|. 

Si possono usare dichiarazioni locali per evitare di dover calcolare più volte il valore di un'espressione, usata più volte. 
Una funzione può essere dichiarata localmente se non ha un significato autonomo, all'esterno della funzione dove viene usata e se consente di diminuire il numero di parametri. 

\subsubsection{Esempio: \texttt{split\_string}}

Utilizzando dichiarazioni locali è possibile inserire in una sola funzione tute le funzioni ausiliarie definite precedentemente:
\begin{minted}{ocaml}
    let primo_non_numerico s =
        let rec loop i = 
            if (s.[i] < '0' || s.[i] > '9') then i
            else loop (i+1)
        in loop 0
\end{minted}

La funzione \verb|substring| viene realizzata tramite la funzione \verb|sub| del modulo String:
\begin{minted}{ocaml}
    let substring s j k =
        String.sub s j ((k-j)+1);;    
\end{minted}

Si può quindi realizzare la funzione \verb|split_string| in questo modo:
\begin{minted}{ocaml}
    let split_string s =
        let i = primo_non_numerico s 
        in (int_of_string (substring s 0 (i - 1)),
            s.[i],
            int_of_string (substring s (i + 1) ((String.length s) - 1)))
\end{minted}

La soluzione al problema descritto, è quindi data dalla seguente funzione \verb|evaluate|:
\begin{minted}{ocaml}
    let evaluate s =
        let (n, op, m) = split_string s
        in if op = '+' then (n + m)
           else if op = '-' then (n - m)
                else if op = '*' then (n * m)
                     else if op = '/' then (n / m)
                          else ???    
\end{minted}
Si incontra un problema poiché la funzione deve restituire un risultato quando la stringa di input non rispetta le condizioni di utilizzo della funzione. Dovrebbe restituire un errore, oppure sollevare un messaggio di errore se il valore di $op$ non coincide ad uno dei quattro operatori. Il problema è che la funzione è di tipo \verb|string| $\rightarrow$ \verb|int|, quindi può solamente restituire un numero intero, anche se l'espressione aritmetica fornita non è valida per poterne calcolare il valore. 

\subsection{Eccezioni}

Si possono definire nuove eccezioni, tramite la parola chiave \verb|exception|, tutte le eccezioni sono di tipo \verb|exn|, permettono di scrivere programmi che segnalano errori. Invece di restituire un valore un'espressione può sollevare un'eccezione. Tutte le funzioni sono in grado di sollevare un'eccezione e terminare immediatamente la loro esecuzione, invece di restituire un valore. 

Esiste un insieme di eccezioni predefinite, iniziano sempre con una lettera maiuscola. Dopo che è stata dichiarata un'eccezione è anche possibile sollevarla, utilizzando la parola chiave \verb|raise|, seguita dall'identificativo dell'eccezione. 
Se durante il calcolo di un'espressione viene sollevata un'eccezione, allora il calcolo del valore termina immediatamente generando l'eccezione. Un'eccezione può essere catturata con un costrutto simile al try-catch di Java, chiamato \verb|try|-\verb|with|. Nel \verb|try| viene inserita un'espressione da calcolare, se viene sollevata un'eccezione durante il calcolo del valore, controlla se il tipo dell'eccezione sollevata corrisponde all'eccezione presente nel costrutto \verb|with|, seguito da \verb|->| che indica un'espressione da eseguire in caso sia verificata l'eccezione. Un'espressione di tipo \verb|exn| può essere il valore di qualsiasi funzione, ed argomento di qualsiasi altra funzione, questo è un eccezione per la tipizzazione forte di OCaml. Si possono usare eccezioni predefinite di OCaml per sollevare eccezioni proprie fornendo commenti più descrittivi. Il nome di tutte le eccezioni comincia con una lettera maiuscola. 

Le eccezioni vengono propagate, se durante il calcolo del valore di un'espressione \verb|E| viene sollevata un'eccezione e non viene catturata, se \verb|E| è un'espressione locale, allora l'eccezione può essere catturata all'interno dell'espressione esterna. Se non viene catturata può continuare ad essere propagata in alto fino alla prima espressione chiamante, e se non viene catturata neanche a questo punto termina l'esecuzione dell'interno programma. 

Un uso non elegante delle eccezioni consiste nell'usare un'eccezione sollevata in un costrutto \verb|try-with| per definire dei casi base per una funzione ricorsiva. In questo modo l'interruzione dell'esecuzione causata dall'eccezione restituisce il valore del caso base dal \verb|with|, mentre per gli altri casi non viene sollevata l'eccezione quindi l'esecuzione continua come se fosse stato implementato un caso base con un controllo. 

\subsubsection{Esempio: \texttt{split\_string}}

Utilizzando un'eccezione si può risolvere il problema proposto, definendo una nuova eccezione e sollevandola se l'operatore non corrisponde a nessuno degli operatori permessi:
\begin{minted}{ocaml}
    exception BadOperation;;
    let evaluate s =
        let (n, op, m) = split_string s
        in if op = '+' then (n + m)
           else if op = '-' then (n - m)
                else if op = '*' then (n * m)
                     else if op = '/' then (n / m)
                          else raise BadOperation;;
\end{minted}

A questo punto utilizzando le eccezioni si possono inserire dei controlli nelle altre funzioni ausiliarie dentro al programma. Se non sono presenti caratteri non numerici, allora dovrebbe essere sollevata l'eccezione \verb|BadOperation|:
\begin{minted}{ocaml}
    let primo_non_numerico s =
        let rec aux i = 
            if (s.[i] < '0' || s.[i] > '9'  ) then i
            else aux (i+1)
        in try aux 0
           with Invalid_argument "index out of bounds" -> raise BadOperation
\end{minted}
L'eccezione catturata si verifica quando si esce fuori dall'indice consentito di una stringa. Si utilizza il nome \verb|aux| per indicare una funzione ausiliaria generica. 

La funzione \verb|split_string| può fallire quando viene chiamata \verb|int_of_string| se la sotto-stringa che le viene passata non corrisponde ad un intero, dato che solo il primo carattere non numerico viene rimosso, se ne è presente più di uno questo provoca il fallimento della funzione. Si può quindi definire una nuova eccezione:
\begin{minted}{ocaml}
    exception BadInt;;
    let split_string s =
        let i = primo_non_numerico s 
        in try (int_of_string (substring s 0 (i - 1)),
                s.[i],
                int_of_string (substring s (i + 1) ((String.length s) - 1)))
           with Failure "int_of_string" -> raise BadInt
\end{minted}

\subsection{Pattern}

L'uso di costrutti condizionali è molto usato e comune, e sarebbe utile per molte applicazioni poter semplificare la loro scrittura. In diversi linguaggi di programmazione sono presenti costrutti simili ad uno \textit{switch-case}, l'equivalente in OCaml e nei linguaggi ML sono i \textit{pattern}. 
Quando si effettua una dichiarazione su una variabile \verb|x|, questo è un caso particolare di pattern. 
Una dichiarazione è quindi generalmente costituita dalla parola chiave \verb|let|, seguita da un pattern, a cui viene assegnato il valore di un'espressione. 
La forza principale di OCaml consiste in questa abilità di \textit{pattern matching}. Un pattern è un'espressione costituita da variabili e/o costruttori di tipo, per i tipi introdotti fin'ora i costruttori sono tutti e soli i valori dei tipi \verb|int|, \verb|float|, \verb|bool|, \verb|char|, \verb|string| ed \verb|unit|, ed i costruttori di tuple: \verb|(,)|. In un pattern però non possono esserci ripetizioni di una stessa variabile, eccetto la variabile muta \verb|()|. 
Espressioni condizionali o contenenti operatori aritmetici non sono pattern, il pattern matching costituito da una sola variabile e qualunque espressione ha sempre esito positivo, non avendo restrizioni di alcun modo sui tipi. 

Dato un pattern \verb|P|, un certo valore \verb|V| si dice conforme al pattern \verb|P|, se è possibile sostituire le variabili in \verb|P| con il valore di sotto-espressioni di \verb|V|, in modo da ottenere \verb|V| stesso. 
Ogni espressione \verb|E| ha un suo valore \verb|V|, quindi si può generalizzare la concezione di pattern matching. 
L'operazione di pattern matching consiste nel confrontare un espressione \verb|E| con un pattern \verb|P|. Il confronto ha successo se il valore ottenuto \verb|V| è conforme al pattern \verb|P|, se ha successo allora si determina come sostituire le variabili di \verb|P| per ottenere il valore \verb|V|. Quindi viene esteso l'ambiente corrente, inserendo i legami risultanti dal pattern matching. 


Anche nelle dichiarazioni di funzioni i parametri sono pattern, permettendo di evitare l'uso di selettori all'interno del corpo della funzione. Le espressioni funzionali si scrivono allo stesso modo di una dichiarazione, utilizzando pattern. Definendo una funzione in maniera esplicita o utilizzando espressioni funzionali, il parametro può essere sempre un pattern. 

In generale quindi le espressioni \verb|function| sono della forma:
\begin{minted}{ocaml}
    function  P1 -> E1
            | P2 -> E2
            |   ...
            | Pn -> En
\end{minted}
Dove ogni pattern \verb|Pi| ha lo stesso tipo \verb|Tp| ed una sua espressione associata di stesso tipo \verb|Te|. Il tipo dell'espressione \verb|function| è quindi \verb|Tp| $\rightarrow$ \verb|Te|. Si possono anche utilizzare pattern multipli, specificando i pattern da assegnare ad una certa espressione divisi da \texttt{|}. In questo modo si possono scrivere in modo estremamente sintetico e semplice espressioni e funzioni:
\begin{minted}{ocaml}
    let F = function  P1 -> E1
                    | P2 -> E2
                    |   ...
                    | Pn -> En
\end{minted}
Per valutare questa funzione \verb|F| applicata ad un espressione \verb|E|, viene calcolato il valore dell'argomento \verb|V| e si effettua pattern matching con questo valore \verb|V|. A questo punto si effettua il processo descritto precedentemente ed il valore dell'espressione risultante dal pattern match viene riportato come il valore dell'espressione \verb|F E|, e vengono sciolti i legami provvisori. 


Si considera un espressione per il calcolo del fattoriale:
\begin{minted}{ocaml}
    let rec fact = function
          0 | 1 -> 1
        | n -> n * fact(n - 1)
\end{minted} 

L'ordine è estremamente importante, poiché dopo aver calcolato il valore dell'argomento, se il valore è applicata ad un'espressione, questo valore viene confrontato in ordine dal primo pattern in poi. Se il confronto con un pattern ha successo vengono creati legami nell'ambiente con il valore di argomento, poi viene calcolata l'espressione della funzione tramite questo valore, e vengono rimossi i legami precedentemente creati, mantenendo solamente quelli tra argomento e risultato. Quindi anche se il valore potrebbe effettuare un pattern match con pattern successivi, questo viene effettuato solamente con il primo match. 

Si può utilizzare il simbolo \verb|_| come una \textit{wildcard}, può effettuare un pattern match con qualsiasi tipo, ma non viene salvato questo legame nell'ambiente. In un costrutto try-with può essere usata per catturare qualsiasi tipo di eccezione che viene sollevata. 

Un altro costrutto con pattern matching molto utile è il match-with, questo permette di confrontare un'espressione data in input con diversi pattern dello stesso tipo dell'espressione di ingresso. Questo costrutto permette quindi di scegliere quale variabile deve essere confrontata, al contrario del costrutto per \verb|function| che prende l'argomento che gli viene passato, può essere utile in funzioni dove sono richiesti diversi argomenti. Valgono le stesse regole e condizioni generali per i pattern discusse precedentemente:
\begin{minted}{ocaml}
    match E with
          P1 -> E1
        | ...
        | Pn -> En
\end{minted}
Per valutare queste espressioni viene valutata l'espressione in input e ne viene computato il valore \verb|V|, confrontandolo con ogni \verb|P| pattern in ordine. Viene creato il legame con il primo pattern \verb|Pi| che effettua un match ed aggiunto all'ambiente. In seguito viene calcolato il valore dell'espressione \verb|Ei| corrispondente e sciolti i legami ausiliari creati. 


Si può utilizzare per definire funzioni esplicitando i parametri presi in argomento, si considera l'esempio del fattoriale:
\begin{minted}{ocaml}
    let rec fact n =
        match n with
              0 -> 1
            | _ -> n * fact(n - 1)
\end{minted}
Quando il pattern matching non è esaustivo OCaml individua il problema, ma è comunque interpreta l'espressione. Se non si riesce ad effettuare alcun un match viene sollevato un errore di tipo \verb|Match_failure|. 

\subsubsection{Esempio: \texttt{split\_string}}

Utilizzando il pattern matching si può semplificare in modo considerevole la precedente implementazione della funzione, rimuovendo i vari costrutti condizionali annidati con un solo costrutto match:
\begin{minted}{ocaml}
    let evaluate s = 
        let (n, op, m) = split_string s
        in match op with
              '+' -> n + m
            | '-' -> n - m
            | '*' -> n * m
            | '/' -> n / m
            |  _  -> raise BadOperation    
\end{minted}

\clearpage

\section{Costrutti Imperativi e I/O}

Su OCaml nel modulo Pervasives sono presenti delle funzioni per la stampa sullo standard output \verb|stdout|, \verb|print_string| e \verb|print_int| queste funzioni sono di tipo: 
\begin{minted}[mathescape, escapeinside=||]{ocaml}
    val print_string: string |$\rightarrow$| unit
    val print_int: int |$\rightarrow$| unit
\end{minted}
Dove il tipo \verb|unit| contiene un solo elemento \verb|()|. Si vuole realizzare una funzione che permette di stampare a schermo tutti gli interi compresi tra due argomenti $n$ e $m$. 


In OCaml si può realizzare una sequenza di comandi con una notazione simile a quella di una tupla, solamente utilizzando \verb|;| al posto di virgole semplici \verb|,|:
\begin{minted}{ocaml}
    ( E1 ; E2 ; ... ; En)
\end{minted}
Se \verb|Ei| sono espressioni, allora anche questo costrutto è un'espressione formata dalla concatenazione di queste espressioni. Il tipo ed il valore di quest'espressione è dato dall'ultima espressione \verb|En|. Tutte queste espressioni vengono valutate da sinistra verso destra, ma i loro valori vengono ignorati, tranne quello dell'ultima espressione. 
Quindi si potrebbe utilizzare questo costrutto per effettuare tutte le stampe necessarie da questa funzione. 
Se sono presenti degli errori in una di queste espressioni vengono ignorati, e continua la valutazione delle espressioni successive. 

Risulta scomodo provare ad implementare la funzione richiesta utilizzando questi costrutti, poiché dovrebbe essere dinamica rispetto al numero di stampe da effettuare. Si vuole implementare iterativamente, anche se OCaml non fornisce costrutti imperativi, è possibile simulare il loro comportamento iterativo nel modo seguente:
\begin{minted}{ocaml}
    let rec ciclo n m =
        if n > m then ()
        else (print_int n;
              print_newline();
              ciclo (n + 1) m)    
\end{minted}
Questa funzione ricorsiva implementa un'iterazione poiché è \textit{tail recursive}, al ritorno della chiamata ricorsiva, non deve eseguire nulla. 

Si considera una funzione \verb|conta_digits: stringa| $\rightarrow$ \verb|int|, che restituisce il numero di caratteri numerici in una stringa $s$, realizzata in questo modo non è iterativa:
\begin{minted}{ocaml}
    let conta_digits s =
        let rec loop i =
            try if (s.[i] >= '0' && s.[i] <= '9') then 1 + loop (i + 1)
                else loop (i + 1)
            with _ -> 0
        in loop 0    
\end{minted}
Poiché la funzione \verb|loop| non è tail recursive, dato che alla fine di una ricorsione deve ancora effettuare l'operazione di addizione, sulla base del risultato del seguente passo ricorsivo \verb|1 + loop (i + 1)|. Per renderla iterativa, bisogna effettuare quest'operazione prima dell'esecuzione del seguente passo ricorsivo. Si utilizza quindi una variabile di accumulazione \verb|acc|, che ad ogni passo ricorsivo contiene il risultato del passo. In questo modo ad ogni passo ricorsivo si sono già effettuate tutte le operazioni, prima di passare al passo seguente, quindi rappresenta un algoritmo iterativo:
\begin{minted}{ocaml}
    let conta_digits s =
        let rec loop i acc =
            try if (s.[i] >= '0' && s.[i] <= '9') then loop (i + 1) (acc + 1)
                else loop (i + 1) acc
            with _ -> acc
        in loop 0 0    
\end{minted}
Questo accumulatore \verb|acc| rappresenta il risultato parziale di un'iterazione, inizializzato a zero. Questo è il modo in cui vengono realizzati algoritmi ricorsivi in OCaml, dove non sono presenti costrutti imperativi. 

Per leggere input da \verb|stdin| sempre nel modulo Pervasives sono presenti le funzioni \verb|read_line| e \verb|read_int| di tipo \verb|unit| $\rightarrow$ \verb|string| o \verb|int|. 
Si vuole realizzare una funzione che legga degli interi terminata da un punto, e ne restituisca la loro somma:
\begin{minted}{ocaml}
    let rec somma () =
        let s = read_line
        in if s="." then 0
           else (int_of_string s) + somma ()    
\end{minted}
Per realizzare lo stesso algoritmo in versione iterativa, bisogna implementare un accumulatore, in una funzione ausiliaria \verb|aux|:
\begin{minted}{ocaml}
    let somma () =
        let rec aux acc = 
            let s = read_line ()
            in if s="." then acc
               else aux ((int_of_string s) + acc)
        in aux 0
\end{minted}
La funzione ausiliaria \verb|aux| applicata su un argomento $n$ restituisce $n$ sommato agli interi letti dallo \verb|stdin|. Si possono utilizzare le eccezioni, in modo poco elegante, per rendere più sintetico questo approccio. Invece di controllare se il carattere letto è \verb|.| si può effettuare la conversione ad intero, in un try-with, e se la conversione non ha successo, allora termina l'esecuzione, poiché si suppone sia stato passato il carattere \verb|.|. Dato che il comportamento della funzione è analogo al precedente, in questo modo anche se viene inserito un carattere che non è un intero non viene terminata l'esecuzione senza output:
\begin{minted}{ocaml}
    let somma () =
        let rec aux acc =
            try let n = int_of_string (read_line ())
                in aux (n + acc)
            with _ -> acc
        in aux 0
\end{minted}

%% FIXME skipped numero_somma e numero_somma_it

Nei linguaggi iterativi non esiste l'assegnazione quindi un ciclo viene implementato da un costrutto ricorsivo. Questo è la funzione \verb|aux|, che presenta una variabile in più, l'accumulatore \verb|acc| per memorizzare il risultato parziale dell'iterazione. Gli argomenti di questa funzione sono le variabili che vengono modificate nel ciclo. L'operazione principale richiama quella ausiliaria, inizializzando l'accumulatore. In generale questa funzione ausiliaria può avere un corpo del tipo:
\begin{minted}{ocaml}
    if <condizione-uscita> then <valore-uscita>
    else <chiamata-ricorsiva> <argomenti-modificati>
\end{minted}
Gli argomenti modificati sono variabili modificate durante l'iterazione, compreso l'accumulatore. Si considera quindi una possibile implementazione iterativa dell'operazione fattoriale, precedentemente definita ricorsivamente come:
\begin{minted}{ocaml}
    let rec fact = function
          0 | 1 -> 1
        | n -> n * fact (n - 1)
\end{minted}
Iterativamente diventa:
\begin{minted}{ocaml}
    let fact' n = 
        let rec aux acc = function
              0 -> acc
            | n -> aux (n * acc) (n - 1)
        in aux 1 n
\end{minted}
Questa funzione \verb|aux| è iterativa, poiché dopo aver raccolto il risultato per un'iterazione, non deve eseguire altre operazioni. Mentre in un processo ricorsivo, dopo aver ottenuto il risultato della ricorsione bisogna effettuare altre operazioni, nel caso del fattoriale bisogna moltiplicare il valore ottenuto, il fattoriale di $n-1$, per $n$. 


Un processo ricorsivo esegue le operazioni al ritorno dalla ricorsione, mentre in un processo iterativo le operazioni vengono svolte prima della ricorsione l'ultima chiamata ricorsiva può riportare il suo risultato direttamente alla prima. Inoltre un processo ricorsivo ha uno spazio lineare al numero di chiamate ricorsive, mentre in un processo iterativo si usa spazio costante, poiché non c'è bisogno di salvare in memoria le altre chiamate ricorsive. 

Se un problema $P_1$ può essere convertito in un altro problema $P_2$ in modo che una soluzione al primo sia anche soluzione al secondo, senza siano necessari ulteriori calcoli, si dice che il problema $P_1$ è stato ridotto in $P_2$, analogamente si dice che $P_2$ è riduzione di $P_1$. Se una funzione ricorsiva è definita in modo che tutte le sue chiamate ricorsive sono delle riduzioni, allora è una funzione ricorsiva di coda, tail recursive. 

\clearpage

\section{Liste}


%% TODO add caratteristica di OCaml di modificare variabili con costrutti presenti in OCaml, non significa che è lecito utilizzarli essendo un corso di programmazione funzionale

Le liste sono sequenze finite di elementi dello stesso tipo, dove \verb|list| è il costruttore delle liste, preceduto dal tipo degli elementi della lista. La lista vuota è un oggetto polimorfo, indicato con \verb|[]|, di tipo \verb|'a list|. L'inserimento in testa, \textit{cons}, è un'operazione fondamentale denotata da \verb|::|, infisso. I costruttori per le liste sono:
\begin{minted}{ocaml} 
    [] : 'a list
    :: : 'a -> 'a list -> 'a list
\end{minted}
Si possono quindi realizzare liste in modo induttivo, data una lista vuota \verb|[]|, di tipo $\alpha$ \verb|list|, se \verb|x| è di tipo $\alpha$, ed \verb|xs| è di tipo $\alpha$ \verb|list|, allora \verb|(x::xs)| è una $\alpha$ \verb|list|, e nient'altro è un $\alpha$ \verb|list|. 
In questo modo è possibile generare tutte le possibili liste per un dato tipo, per stadi, realizzando un albero radicato in \verb|[]|, ed ogni figlio rappresenta l'aggiunta di un elemento del tipo tramite \verb|x::xs|, dove \verb|xs| è la lista corrispondente al nodo padre. 
%% TODO add img albero generatore liste per tipo

Le liste possono essere costruite ricorsivamente partendo da una lista vuota \verb|[]|, supponendo di poter calcolare il valore su una lista \verb|xs|, si determina come calcolare il valore della generica lista \verb|x::xs|. 

Nel modulo List sono definite funzioni che operano sulle liste, alcune di queste sono:
\begin{itemize}
    \item \verb|List.hd: 'a list| $\rightarrow$ \verb|'a|
    \item \verb|List.tl: 'a list| $\rightarrow$ \verb|'a list|
    \item \verb|List.length: 'a list| $\rightarrow$ \verb|int|
    \item \verb|List.flatten: 'a list list| $\rightarrow$ \verb|'a list|
    \item \verb|List.sort: ('a| $\rightarrow$ \verb|'a| $\rightarrow$ \verb|int)| $\rightarrow$ \verb|'a list| $\rightarrow$ \verb|'a list|
    \item \verb|List.assoc: 'a| $\rightarrow$ \verb|('a * 'b) list| $\rightarrow$ \verb|'b|
    \item \verb|List.rev: 'a list| $\rightarrow$ \verb|'a list|
    \item \verb|List.mem: 'a| $\rightarrow$ \verb|'a list| $\rightarrow$ \verb|bool|
    \item \verb|List.split: ('a * 'b) list| $\rightarrow$ \verb|'a list * 'b list|
    \item \verb|List.combine: 'a list| $\rightarrow$ \verb|'b list| $\rightarrow$ \verb|('a * 'b) list|
    \item \verb|List.sort: ('a| $\rightarrow$ \verb|'a| $\rightarrow$ \verb|int)| $\rightarrow$ \verb|'a list| $\rightarrow$ \verb|'a list|
    \item \verb|List.merge: ('a| $\rightarrow$ \verb|'a| $\rightarrow$ \verb|int)| $\rightarrow$ \verb|'a list| $\rightarrow$ \verb|'a list| $\rightarrow$ \verb|'a list|
\end{itemize}
Le funzioni \textit{head} \verb|hd| e \textit{tail} \verb|tl| sono i selettori di una lista, il primo restituisce il primo elemento ed il secondo restituisce la lista corrispondente senza il primo elemento. Non sono definiti sulla lista vuota \verb|[]|, quindi applicati su di essa viene sollevata un'eccezione.  

\verb|length| restituisce un intero che rappresenta il numero di elementi nella lista. \verb|flatten| trasforma una lista di liste in un'unica grande lista, se gli elementi delle liste contenute nella lista interna non coincidono produce un errore. La funzione \verb|sort| ordina una lista, in base ad una relazione d'ordine espressa come funzione fornita come argomento della funzione. Questa funzione di ordinamento deve essere di tipo \verb|('a| $\rightarrow$ \verb|'a| $\rightarrow$ \verb|int)|, e deve restituire 1 se il primo elemento è maggiore del secondo, 0 se sono uguali, oppure -1 se il primo elemento è minore, secondo una certa relazione d'ordine. 


Si vuole implementare la funzione \verb|length|, senza utilizzare il modulo List. Per implementarla ricorsivamente si considera una lista vuota di lunghezza 0; mentre per un caso generico, la sua lunghezza è $1+n$, dove $n$ è la lunghezza della lista rimosso il primo elemento, si suppone si possa calcolare questo valore $n$. 
La definizione è valida poiché ripetendo l'operazione di coda si arriverà necessariamente alla lista vuota \verb|[]|, la funzione è quindi definita utilizzando il selettore di coda:
\begin{minted}{ocaml}
    let rec length l = 
        if l = [] then 0
        else 1 + (length (List.tl l))
\end{minted}
Alternativamente si può utilizzare il pattern matching sulla lista:
\begin{minted}{ocaml}
    let rec length = function
          [] -> 0
        | _::xs -> 1 + (length xs)
\end{minted}
In un pattern possono occorrere solo variabili o costruttori, \verb|[]| e \verb|::|. Utilizzando questi due costruttori si può individuare il caso base di una lista vuota \verb|[]| ed il caso con una lista avente almeno un elemento \verb|x::xs|, dove a \verb|x| viene assegnato il valore del primo elemento della lista, ed a \verb|xs| viene assegnato il valore della lista rimanente. 
Questa modalità è un'alternativa all'uso dei selettori di testa e di coda per le liste. Analogamente si può effettuare pattern matching per un certo numero di elementi specifico in una lista con \verb|[x1;...x;n]|, questo pattern avrà successo solo se la lista su cui si vuole effettuare il match ha esattamente $n$ elementi ed il valore di tutti i componenti \verb|xi| assumerà il valore corrispondente dell'elemento $i-$esimo della lista. Oppure si può realizzare con \verb|x1::...::xn::xs|, dove \verb|xs| conterrà la lista vuota \verb|[]| se la lista su cui si è effettuato il match ha esattamente $n$ elementi, altrimenti sarà composta dalla coda della lista. 

Per realizzare la funzione \verb|length| ricorsivamente si considera la seguente implementazione:
\begin{minted}{ocaml}
    let length' l =
        let rec aux acc = function
            | [] -> acc
            | _::xs -> aux (1 + acc) xs
        in aux 0 l    
\end{minted}

Un'altra funzione simile che si può implementare calcola il prodotto di tutti gli interi di una lista \verb|prodof: int| $\rightarrow$ \verb|int|. Si realizza sia in modo ricorsivo che iterativo:
\begin{minted}{ocaml}
    let rec prodof = function
        | [] -> 1
        | x::xs -> x * (prodof xs)
    ;;
    let prodof' l = 
        let rec aux acc = function
            | [] -> acc
            | x::xs -> aux (x * acc) xs
        in aux 1 l
    ;;
\end{minted}


\subsection{Esempio: \texttt{super}}

Si vuole creare una funzione che, date le ultime $n$ estrazioni del superenalotto, restituisca i numeri che sono stati estratti meno volte. Questa funzione \verb|super| prende come parametro la lista di liste \verb|est|, rappresentanti le ultime estrazioni, il numero di interi di ogni estrazione $n$ ed il massimo numero che può essere estratto $h$:
\begin{minted}[mathescape, escapeinside=||]{ocaml}
    - super: int list list |$\rightarrow$| int |$\rightarrow$| int |$\rightarrow$| int list
    super est n h
\end{minted}
Si definisce il sotto-problema di determinare quante volte un numero $m$ compreso da 1 ad $h$ compare in tutte le estrazioni \verb|est|. Per poi iterare su tutti i possibili numeri che possono essere estratti. 
Per determinare questi numeri, si definisce la funzione \verb|upto: int| $\rightarrow$ \verb|int| $\rightarrow$ \verb|int list|, applicata sugli argomenti $i$ $j$ produce una lista da $i$ a $j$: \verb|upto i j =[i;...;j]|:
\begin{minted}{ocaml}
    let rec upto i j =
        if i > j then []
        else i::(upto (i + 1) j)    
\end{minted}
Si può realizzare in modo ricorsivo come il seguente:
\begin{minted}{ocaml}
    let upto' i j =
        let rec aux acc i' j' =
            if i' > j' then acc
            else aux (j'::acc) i' (j' - 1)
        in aux [] i j
\end{minted}
L'ultima riga potrebbe essere scritta come \verb|else aux| \verb|(m'::acc)| \verb|(m'+1) n'|, ma in questo modo si inverte l'ordine della lista creata. Nelle due versioni si aggiunge sempre in testa, partendo dall'estremo inferiore nel primo caso e dall'estremo superiore nel secondo caso. 


Per poter utilizzare facilmente la lista delle estrazioni, bisogna appiattirla, da una lista di liste ad una lista, quindi bisogna definire una funzione \verb|flatten:| \verb|'a list list| $\rightarrow$ \verb|'a list|:
\begin{minted}{ocaml}
    let rec flatten = function
          [] -> []
        | x::xs -> x@(flatten xs)
\end{minted}
La funzione \verb|flatten| in maniera ricorsiva ha la seguente implementazione:
\begin{minted}{ocaml}
    let rec flatten ll 
        let aux acc = function 
              [] -> acc
            | x::xs -> flatten (acc@x) xs 
        in aux [] ll
\end{minted}
Si definisce quindi una funzione per contare quante volte uno solo dei numeri possibili è stato estratto, che verrà applicata su tutti i possibili numeri, \verb|conta:| \verb|'a| $\rightarrow$ \verb|'a list| $\rightarrow$ \verb|int|:
\begin{minted}{ocaml}
    let rec conta x = function
          [] -> 0
        | y::ys -> if y = x then 1 + (conta x ys)
                   else conta x ys
\end{minted}
In forma iterativa diventa:
\begin{minted}{ocaml}
    let conta x l =
        let rec aux x' l' acc = match l with
                  [] -> acc
                | y::ys -> if y = x' then aux x' ys (acc + 1)
                           else aux x' ys acc
        in aux x l 0
\end{minted}

Si definisce ora una funzione per contare tutti questi possibili numeri, \verb|contatutti:| \verb|'a list| $\rightarrow$ \verb|'a list| $\rightarrow$ \verb|('a * int) list|. Il primo argomento $l_1$ è la lista contenente i possibili numeri, mentre il secondo $l_2$ è la lista contenente tutte le estrazioni. 
Questa funzione restituisce una lista di coppie, dove il primo elemento rappresenta l'elemento cercato, mentre il secondo è il suo numero di occorrenze:
\begin{minted}{ocaml}
    let rec contatutti l1 l2 = match l1 with
          [] -> []
        | x::xs -> (x, conta x l2)::(contatutti xs l2)    
\end{minted}


Utilizzando le funzioni definite si può ottenere la lista delle coppie dei possibili numeri e la loro occorrenza:
\begin{minted}{ocaml}
    contatutti (upto 1 h) (flatten est)    
\end{minted}

Per scegliere gli elementi che sono stati estratti il numero minore di volte, si può ordinare la lista, utilizzando una funzione \verb|sort:| \verb|('a * 'b) list| $\rightarrow$ \verb|('a * 'b) list|. Si può usare la funzione \verb|List.sort| fornita da OCaml nel modulo List, questa può ordinare una lista passata come parametro rispetto ad una certa relazione d'ordine espressa tramite un'espressione passata come primo argomento alla funzione. Si definisce quindi una relazione d'ordine \verb|comp:| \verb|('a * 'b)| $\rightarrow$ \verb|('c * 'b)| $\rightarrow$ \verb|int| tra due elementi, o coppie, di questa lista:
\begin{minted}{ocaml}
    let comp (_, x) (_, y) = if x < y then -1
                             else if x = y then 0
                             else 1
\end{minted}
Si definisce ora la funzione \verb|sort| come:
\begin{minted}{ocaml}
    let sort l = List.sort comp l
\end{minted}


Ottenuta la lista ordinata, per ottenere una lista dei numeri meno estratti, bisogna prima prendere un certo numero di elementi dalla lista ordinata, tramite una funzione \verb|take:| \verb|int| $\rightarrow$ \verb|'a list| $\rightarrow$ \verb|'a list|, che applicata ad un intero $n$ ed una lista $l$ restituisce una sottolista di lunghezza $n$, partendo dalla testa della lista $l$:
\begin{minted}{ocaml}
    let rec take n = function
          [] -> []
        | x::xs -> if n <= 0 then []
                   else x::(take (n - 1) xs)
\end{minted}
Per realizzarla in modo ricorsivo, non si può utilizzare l'operatore cons, altrimenti ad ogni passaggio si aggiungerebbe la testa della lista all'accumulatore, invertendo l'ordine \verb|x::acc|. Questo avviene perché in un approccio iterativo si effettuano tutte le operazioni in un passo prima di effettuare la ricorsione, quindi viene aggiunta subito l'elemento all'accumulatore, prima di passarlo all'iterazione successiva Quindi per mantenere l'ordine bisogna effettuare una concatenazione:
\begin{minted}{ocaml}
    let take' n l = 
        let aux acc n' = function
              [] -> acc
            | x::xs if n' > 0 then aux (acc@[x]) (n' - 1) xs
                    else acc 
        in aux [] n l
\end{minted}
Ma la concatenazione è un'operazione molto costosa, quindi sarebbe meglio creare una lista inversa e poi invertirla alla fine. Si considera quindi una funzione \verb|rev: 'a list| $\rightarrow$ \verb|'a list| che inverte l'ordine di una lista:
\begin{minted}{ocaml}
    let rec rev = function
        | [] -> []
        | x::xs -> (rev xs)@[x]    
\end{minted}
Ma in modo ricorsivo utilizza comunque la concatenazione costosa, quindi si utilizza un'implementazione iterativa:
\begin{minted}{ocaml}
    let rev l =
        let rec aux acc = function
            | [] -> acc
            | x::xs -> aux (x::acc) xs
        in aux [] l
\end{minted}
Una funzione di inversione è comunque presente nel modulo List di OCaml, quindi si può utilizzare invece di definire una nuova funzione. L'approccio ricorsivo per la funzione \verb|take| è quindi:
\begin{minted}{ocaml}
    let take'' n l = 
        let rec aux acc n' = function
            | [] -> acc
            | x::xs -> if n' > 0 then aux (x::acc) (n' - 1) xs
                       else acc 
        in List.rev (aux [] n l)
\end{minted}

A questo punto non è più di interesse il numero di occorrenze, quindi si definisce una funzione \verb|primi:| \verb|('a * 'b) list| $\rightarrow$ \verb|'a list|, per restituire una lista contenete solo il primo elemento delle coppie:
\begin{minted}{ocaml}
    let rec primi = function
          [] -> []
        | (x, y)::l -> x::(primi l)
\end{minted}

Si può quindi definire la funzione \verb|super| come:
\begin{minted}{ocaml}
    let super est n h = primi (take n (sort (contatutti (upto 1 h) (flatten est))))    
\end{minted}

\subsection{Esempio: \texttt{merge sort}}

Il merge sort è un algoritmo di ordinamento che applica la tecnica del \textit{divide et impera}, consiste nel dividere un dato insieme da ordinare ricorsivamente ed ordinare i sottoinsiemi con lo stesso algoritmo di merge sort. Le due parti vengono divise in modo al più uguale. 
Per implementare il merge sort, bisogna definire una funzione che divida una lista in due metà, al massimo differenti di un elemento per lunghezza. 
Si vuole quindi definire la funzione \verb|split:| \verb|'a list| $\rightarrow$ \verb|'a list * 'a list|:
\begin{minted}{ocaml}
    let rec split = function
          [] -> ([], [])
        | [x] -> ([x], [])
        | x::y::rest -> let (xs, ys) = split rest
                        in (x::xs, y::ys)
\end{minted}
Le due parti della lista devono avere la stessa lunghezza, o al massimo variare di uno, ci sono due casi base, se la lista è vuota o ha un solo elemento. Se si hanno almeno due elementi si spacca a metà la lista, togliendo i primi due elementi \verb|x| e \verb|y| e si mettono in testa allo divisione successiva \verb|xs| \verb|ys|. 
Si può realizzare in modo più succinto, considerando solo due casi, una lista vuota o non vuota, e si alterna a quale lista viene aggiunto l'elemento successivo:
\begin{minted}{ocaml}
    let rec split = function
        | [] -> ([], [])
        | x::xs -> let (ys, zs) = split xs
                    in (x::zs, ys)
\end{minted}
Per implementare l'algoritmo di merge sort, bisogna prima implementare la funzione merge, questa funzione deve unire due liste e mantenere il loro ordinamento. Si realizza la funzione \verb|merge:| \verb|'a list| $\rightarrow$ \verb|'a list| $\rightarrow$ \verb|'a list|, considerando un ordinamento non decrescente:
\begin{minted}{ocaml}
    let rec merge l1 l2 = match (l1, l2) with
        | ([], l) | (l, []) -> l
        | (x::xs, y::ys) -> if x < y then x::(merge xs (y::ys))
                            else y::(merge (x::xs) ys)
\end{minted}
L'algoritmo di merge sort quindi si implementa semplicemente come:
\begin{minted}{ocaml}
    let rec mergesort = function
        |  [] -> []
        | [x] -> [x]
        | l -> let (l1, l2) = split l
               in merge (mergesort l1) (mergesort l2)
\end{minted}

\clearpage

\section{Collezioni e Backtracking}


Un tipo astratto di dato è costituito da un insieme di oggetti ed un insieme di operazioni che operano su questi oggetti. 
Per rappresentare un tipo astratto di dato bisogna almeno riferirsi ad un tipo di dato concreto. Quindi per rappresentare un tipo astratto di dato \verb|A|, bisogna determinare un tipo concreto \verb|T|, tale che ogni oggetto del tipo astratto di dato abbia almeno un rappresentante in \verb|T|, ed elementi distinti del tipo \verb|A| abbiano rappresentanti distinti in \verb|T|. 
Bisogna implementare ogni operazione $F$ su \verb|A| con un'operazione $P$ su \verb|T|, in modo da conservare le operazioni. Ovvero se $v_i$ sono valori di \verb|T|, che rappresentano valori $a_i$ di \verb|A|, allora $P(a_1,\cdots,a_n)$ è un rappresentante di $F(v_1,\cdots,v_n)$. 
Quindi invece di operare direttamente oggetti di \verb|A| si può operare sui loro rappresentanti in \verb|T| ed in seguito si può determinare il corrispettivo in \verb|A|. 

Siano $\mathscr{A}=(A,f_1\cdots,f_n)$ e $\mathscr{B}=(B,g_1,\cdots,g_n)$ due strutture algebriche dello stesso tipo, con ogni funzione $f_i$ e $g_i$ che prendano lo stesso numero di argomenti. Una rappresentazione di $\mathscr{A}$, tipo astratto, in $\mathscr{B}$, tipo concreto, è un'applicazione, funzione parziale: $\varphi:\mathscr{B}\to\mathscr{A}$, tale che è suriettiva: $\forall a\in A \,\exists b\in B\implies \varphi(b)=a$; ed è un omomorfismo: $\forall b_k\in B\implies\varphi(g_i(b_1,\cdots,b_n))=f_i(a_1,\cdots,a_n)$. 
%% TODO add img par 5.1.2 libro 9/16 PF05.pdf

\subsection{Dizionari}

Un tipo di astratto dato interessante sono dizionario, una collezione di elementi ciascuno costituito da una coppia chiave-valore. Ogni elemento ha chiave distinta. 
Su questa collezione si può cercare un elemento per chiave, inserire una coppia di elementi, e cancellare un elemento, data la chiave. Si possono implementare in OCaml tramite liste associative. 

Una lista associativa è una lista di coppie, del tipo \verb|('a * 'b) list|, sulle chiave deve esistere una relazione di uguaglianza. Quindi deve utilizzare un tipo che permette l'uguaglianza. 

Data una lista associativa che implementa un dizionario, si vuole realizzare una funzione \verb|assoc: 'a| $\rightarrow$ \verb|('a * 'b) list| $\rightarrow$ \verb|'b|, che data una chiave $k$ ed una lista associativa $l$, restituisce, se esiste, il valore $v$ corrispondente della chiave $k$ nel dizionario $l$. Se non viene trovato l'elemento bisogna sollevare un'eccezione, dato che non può restituire alcun valore:
\begin{minted}{ocaml}
    exception NotFound;;
    let rec assoc k = function
        | [] -> raise NotFound
        | (k', v)::rest -> if k = k' then v
                           else assoc k rest
\end{minted}
Questa dichiarazione non è corretta poiché nell'istruzione dichiarativa il tipo del costrutto \verb|then| è il tipo di \verb|v|, mentre nell'\verb|else| il tipo restituito è una funzione e non coincide ad un valore. 
Nel modulo List è presenta una funzione \verb|List.assoc| che effettua la stessa operazione, e solleva un'eccezione \verb|Not_found| se non trova una chiave corrispondente. 
Per inserire un valore in un dizionario, bisogna prima eliminare la vecchia coppia che occupava quella chiave. Essendo troppo costoso per inserire una nuova coppia questa viene inserita in testa al dizionario, mente le vecchie coppie obsolete si trovano dopo questa nuova coppia. Quindi l'inserimento di una coppia chiave-valore $k$-$v$, viene quindi realizzato da una funzione \verb|inserisci 'a| $\rightarrow$ \verb|'b| $\rightarrow$ \verb|('a * 'b) list| $\rightarrow$ \verb|('a * 'b) list|,
che inserisce il nuovo elemento in testa, in modo che venga scelto prima nella ricerca, e quindi ``sovrascrive'' il valore successivo diventato obsoleto:
\begin{minted}{ocaml}
    let inserisci k v l = (k, v)::l    
\end{minted}
Per cancellare una coppia chiave-valore dato che potrebbero essere presenti più coppie con la stessa chiave per l'implementazione precedente, bisogna eliminare tutte le coppie chiave-valore presenti nella lista, che coincidono alla chiave $k$ fornita come argomento alla funzione \verb|cancella: 'a| $\rightarrow$ \verb|('a * 'b) list| $\rightarrow$ \verb|('a * 'b) list|:
\begin{minted}{ocaml}
    let rec cancella k = function
          [] -> []
        | (k', v)::rest -> if k = k' then cancella k rest
                           else  (k', v)::(cancella k rest)
\end{minted}

\subsection{Insiemi}

Un insieme finito è un tipo astratto di dato capace di contenere elementi, in questa implementazione dello stesso tipo, univoci all'interno dell'insieme. Ovvero in un'istanza di questo tipo astratto di dato può essere presente un unico elemento sulla base di una certa relazione di uguaglianza. 
Per gli insiemi sono definite le operazioni di ricerca $\in$, di unione $\cup$, intersezione $\cap$ e sottrazione tra insiemi $\setminus$. Il tipo concreto è una lista $l$ che contiene esattamente gli elementi dell'insieme. Ogni lista di tipo \verb|'a list| rappresenta un unico insieme. Si devono definire le quattro operazioni descritte sul tipo astratto:
\begin{itemize}
    \item \verb|mem: 'a| $\rightarrow$ \verb|'a list| $\rightarrow$ \verb|bool|: è un predicato che restituisce se un elemento $x$ appartiene ad un insieme $S$, $x\in S$
    \item \verb|union: 'a list| $\rightarrow$ \verb|'a list| $\rightarrow$ \verb|'a list|: applicata a due liste $l_1$ ed $l_2$ che rappresentano due insiemi $S_1$ e $S_2$ restituisce una rappresentazione di $S_1\cup S_2$
    \item \verb|intersect: 'a list| $\rightarrow$ \verb|'a list| $\rightarrow$ \verb|'a list|: applicata a due liste $l_1$ ed $l_2$ che rappresentano due insiemi $S_1$ e $S_2$ restituisce una rappresentazione di $S_1\cap S_2$
    \item \verb|setdiff: 'a list| $\rightarrow$ \verb|'a list| $\rightarrow$ \verb|'a list|: applicata a due liste $l_1$ ed $l_2$ che rappresentano due insiemi $S_1$ e $S_2$ restituisce una rappresentazione di $S_1\setminus S_2$
\end{itemize}
Anche se una lista contenete ripetizioni è una rappresentazione contenente una sola istanza di quell'elemento, per evitare di creare liste eccessivamente lunghe si impone che le liste rappresentazioni di insiemi non abbiano ripetizioni. 

Per implementare la ricerca, bisogna semplicemente iterare sulla lista e controllare se l'elemento corrente coincide a l'elemento $x$ su cui viene applicata la funzione \verb|mem|:
\begin{minted}{ocaml}
    let rec mem x = function
        | [] -> false
        | y::ys -> y = x || (mem x ys)
\end{minted}

La funzione di unione potrebbe semplicemente concatenare le due liste rappresentazioni, ma si vuole imporre la condizione che non possono esserci elementi ripetuti su di una stessa lista rappresentazione, quindi bisogna controllare la presenza prima di aggiungere un altro elemento:
\begin{minted}{ocaml}
    let rec union l = function
        | [] -> l
        | x::xs -> if mem x l then union l xs
                   else x::(union l xs)    
\end{minted}
In modo iterativo invece:
\begin{minted}{ocaml}
    let union' l1 l2 = 
        let rec aux l' = function
            | [] -> l'
            | x::xs -> if mem x l' then union l' xs
                       else union (x::l') xs
        in aux l1 l2
\end{minted}
Poiché il caso base restituisce la prima lista, ed essenzialmente bisogna aggiungere ad ogni iterazione un elemento alla prima lista, o seconda in base all'implementazione, essenzialmente rappresenta un accumulatore, quindi non è necessario utilizzarne uno. 

Per la funzione intersezione invece questo non può essere effettuato, per la sua versione iterativa; la funzione è essenzialmente la stessa, ma bisogna aggiungere un elemento solo se è presente in entrambe le liste:
\begin{minted}{ocaml}
    let rec intersect l = function
        | [] -> []
        | x::xs -> if mem x l then x::(intersect l xs)
                   else intersect l xs
\end{minted}
Un algoritmo iterativo, invece necessita di un accumulatore:
\begin{minted}{ocaml}
    let intersect' l1 l2 = 
        let rec aux acc l' = function
            | [] -> acc 
            | x::xs -> if mem x l' then aux (x::acc) l' xs
                       else aux acc l' xs
        in aux [] l1 l2    
\end{minted}

Si considera una possibile implementazione della differenza tra due insiemi:
\begin{minted}{ocaml}
    let rec setdiff l1 l2 = match l1 with 
        | [] -> []
        | x::xs -> if mem x l2 then setdiff xs l2
                   else x::(setdiff xs l2)
\end{minted}
In maniera iterativa:
\begin{minted}{ocaml}
    let setdiff' l1 l2 =
        let rec aux acc l1' l2' = match l1' with
            | [] -> acc
            | x::xs -> if mem x l2' then aux acc xs l2'
                       else aux (x::acc) xs l2'
        in aux [] l1 l2
\end{minted}

\subsection{Backtracking}

Il \textit{backtracking} è una delle tecniche più importanti nella progettazione di algoritmi. L'idea è di costruire una soluzione in modo incrementale, in OCaml si può realizzare semplicemente. Questo algoritmo è simile ad una ricerca in ampiezza, ma è completa, poiché dopo aver trovato tutte le soluzioni scarta quelle peggiori e mantiene la soluzione migliore. 

I candidati ad essere soluzioni sono una sequenza di elementi $x_i$ appartenenti all'insieme delle possibili soluzioni $S$. L'approccio di ``forza bruta'' considera tutte le possibili combinazioni; l'algoritmo di backtracing costruisce una sequenza $x_1,\cdots,x_i$, scegliendo ad ogni passo un nuovo elemento $x_{i+1}$ da aggiungere alla sequenza, ed analizza se questa sequenza ha possibilità di successo. Se è una soluzione mantiene la sequenza, altrimenti sceglie un altro elemento $x_{i+1}$ da aggiungere alla sequenza. 
Una condizione principale è di non poter tornare indietro per elementi già visitati, e presenti nella sequenza. Questa condizione dipende dal problema su cui viene utilizzato l'algoritmo. 

\subsubsection{Somma di Sottoinsiemi}

Un problema tipico dell'informatica è la somma di sottoinsiemi: dato un insieme di interi positivi $S$ ed un intero $n$, determinare un sottoinsieme $Y$ di $S$: $Y\subseteq S$, tale che la somma degli elementi di $Y$ sia uguale al valore dell'intero $n$. 

Si risolve mediante il backtracking, considerando come lo spazio di ricerca delle soluzioni un albero di tutti i possibili sottoinsiemi di $S$, che rispettano la condizione della somma. Le foglie quindi possono essere delle soluzioni valide oppure sottoinsiemi non validi, ed in caso non è necessario espanderli ulteriormente. Una volta esplorato un sotto-albero viene rimossa la sua radice e si continua la ricerca. 
%% TODO img albero sottoinsiemi ppt


Ad ogni stadio della ricerca si considerano due insiemi degli elementi visitati o da visitare, $\hat{S}$ e $\hat{\bar{S}}$, uno complementare dell'altro. All'inizio si ha che $\hat{S}=\emptyset$ è lo spazio di ricerca delle soluzioni e $\hat{\bar{S}}=S$. 
Se la somma degli elementi di $\hat{S}$ è maggiore di $n$ si ha una soluzione non valida, e si scarta l'ultimo elemento aggiunto, se è uguale ad $n$ si ha identificato una soluzione. Se la somma è minore invece ed $\hat{\bar{S}}=\emptyset$ allora non è una soluzione valida, se non è vuoto allora si sceglie un elemento $x\in\hat{\bar{S}}$, e si cerca una soluzione aggiungendo $x$ alla soluzione $\hat{S}$ con $\hat{S}\cup\{x\}$ e $\hat{\bar{S}}\setminus\{x\}$ oppure senza aggiungerlo alla soluzione con $\hat{S}$ e $\hat{\bar{S}}\setminus\{x\}$.  

Per implementare un algoritmo risolutivo di questo problema si considera una funzione ausiliaria \verb|sum| che somma tutti gli elementi di una lista:
\begin{minted}{ocaml}
    let rec sum = function
        | [] -> 0
        | x::xs -> x + (sum xs)    
\end{minted}
In modalità iterativa:
\begin{minted}{ocaml}
    let sum' l =
        let rec aux tot = function
              [] -> tot
            | x::xs -> aux (tot + x) xs
        in aux 0 l
\end{minted}

Si definisce un'eccezione \verb|NotFound| in caso la soluzione individuata non rappresenta una soluzione del problema:
\begin{minted}{ocaml}
    exception NotFound
\end{minted}
Si implementa ora l'algoritmo:
\begin{minted}{ocaml}
    let search_subset set n = 
        let rec search_aux sol others =
            let s = sum' sol
            in if s = n then sol
               else if s > n then raise NotFound
                    else match others with
                        | [] -> raise NotFound
                        | x::xs -> try search_aux (x::sol) xs
                                   with NotFound -> search_aux sol xs
        in search_aux [] set
\end{minted}
Per creare una versione generale che restituisce tutte le possibili soluzioni, si creano delle funzioni ausiliarie:
\begin{minted}{ocaml}
    let rec mapcons a = function
        | [] -> []
        | l::ls -> (a::l)::(mapcons a ls)
\end{minted}
Questa funzione data una lista di liste, aggiunge in testa a tutte le liste contenute l'argomento $\alpha$ su cui viene applicata. 


In questo modo si può definire la funzione \verb|search_all| che cerca tutte le possibili soluzioni:
\begin{minted}{ocaml}
    let rec search_all tot = function
        | [] -> if tot > 0 then []
                else [[]]
        | x::xs -> if x > tot then search_all tot xs
                   else (mapcons x (search_all (tot - x) xs)) @ (search_all tot xs)  
\end{minted}
Questa funzione lavora cercando tutti i sottoinsiemi ricorsivamente creando un albero di sottoinsiemi, ogni volta che viene rimosso un elemento, ovvero scendendo da un ramo dell'albero, viene diminuito il parametro \verb|tot|, se è uguale a zero, allora la sequenza corrente corrisponde ad una soluzione, altrimenti bisogna effettuare backtracing. 
Ad ogni iterazione si rimuove l'elemento in testa e si determinano tutte le soluzioni nei due sottoinsiemi creati mantenendo e rimuovendo questo elemento in testa. Chiamandola ricorsivamente si scorre per intero l'albero dei sottoinsiemi possibili, ed arrivate alle foglie si scartano le soluzioni non valide e si concatenano tra di loro tutte le soluzioni individuate. Si utilizza la funzione \verb|mapcons| per inserire l'elemento rimosso per ricreare il sottoinsieme soluzione.  

\subsubsection{Problema delle 8 Regine}

Un problema comune chiamato problema delle 8 regine, consiste nell'individuare su una scacchiare una configurazione di otto regine, in modo che non siano mai sotto attacco. Poiché le regine possono attaccare su l'intera riga e colonna dove sono disposte, un modo per semplificare il problema, consiste nel posizionare le regine in tutte le righe e colonne, senza avere più regine sulla stessa riga e colonna, altrimenti sarebbero sicuramente sotto attacco. 
Il problema quindi consiste nel trovare una configurazione di otto regine, dove le diagonali non incontrano mai altre regine. 
Utilizzando il metodo della soluzione incrementale consiste nel piazzare una regina su una casella, e controllare se mettendo le restanti regine si trova una soluzione valida, altrimenti si ritorna a questa posizione iniziale e si sceglie un'altra casella. 

Scomponendo il problema in sotto-problemi è sicuramente necessario avere una funzione che indica se una regina è sotto attacco. Questa funzione deve avere come parametri due posizioni, quindi due coppie di interi, e deve restituire un booleano se queste due posizione, contenessero delle regine, sarebbero sotto attacco l'una rispetto all'altra. Anche se non si tratta di uno scacco, è più intuitivo parlare di scacco, piuttosto di attacco, per indicare che la soluzione non è valida. 
Date due coppie di interi $i,j$ e $m,n$ se le due regine sono sulla stessa diagonale ascendente, allora la distanza attraversata in diagonale deve essere uguale, questa distanza si ottiene sommando le due coordinate. Mentre per determinare se sono sulla stessa diagonale discendente bisogna controllare che scendendo dalle coordinate $i$, $j$ a $i-m$ e $j-n$ ci si trova nella stessa diagonale. 
Mentre sono sicuramente sotto attacco se la colonna o la riga è uguale. 
\begin{minted}{ocaml}
    let scacco ( i, j ) ( m, n ) =
        i = m || ( i - m = j - n) || ( i + j = m + n ) || j = n
\end{minted}


Poiché su ogni colonna può esserci una sola colonna, una regina viene individuata in maniera univoca solamente dalla sua colonna. Per sapere su quale riga si trova, si considera una lista, dove l'indica su quale riga si trova, mentre il valore contenuto è variabile ed indica la colonna su cui si trova attualmente nella scacchiera. Quindi la riga delle regine è sempre fissata, mentre possono traslare sulle colonne:
\begin{minted}{ocaml}
    let board = [1;2;3;4;5;6;7;8]
\end{minted}
% soluzione corretta:
% let board = [6;3;1;8;5;2;4;7]
In questa rappresentazione, quindi non è necessaria la condizione per il controllo sulla riga:
\begin{minted}{ocaml}
    let scacco (i, j) (m, n) =
        i = m || (i - m = j - n) || (i + j = m + n)
\end{minted}
Per evitare di accedere alla lista per ottenere l'indice si può realizzare direttamente una lista di coppie. Per passare a questa rappresentazione si crea una funzione ausiliaria:
\begin{minted}{ocaml}
    let combine l = 
        let rec aux n acc = function
              [] -> acc
            | x::xs -> aux (n + 1) ((x,n)::acc) xs
        in List.rev(aux 1 [] l)
\end{minted}
Si crea quindi una funzione \verb|safe| che controlla data una configurazione della scacchiera, se una certa riga $m$ è libera. %% ??
Questa funzione prova ad aggiungere una regina alla riga $m$, se non sono presenti regine sulla scacchiera allora si può aggiungere senza problemi, altrimenti bisogna controllare se si può posizionare su una delle colonne della riga $m$, senza che sia sotto attacco. Se ciò non è possibile allora restituisce falso. 
% let board = [1;1;1]
% safe board 1
% \begin{minted}{ocaml}
%     let safe board m =
%         let c = List.length board + 1 in 
%         let rec aux n = function
%               [] -> false
%             | x::xs -> scacco (x, n) (m, c) || aux (n + 1) xs
%         in not (aux 1 board)    
% \end{minted}
\begin{minted}{ocaml}
    let safe board m =
        let n = List.length board
        in let rec aux = function
              [] -> true
            | (i, j)::xs -> not (scacco (i, j) (m, n + 1)) && aux xs
        in aux (combine board)    
\end{minted}

Il problema ora consiste nell'utilizzare questa funzione \verb|safe| per trovare una soluzione al problema. Si definisce un'eccezione \verb|NotFound| in caso non si è trovata una soluzione: 
\begin{minted}{ocaml}
    exception NotFound;;
    let queens n = 
        let rec aux sol i j = 
            if j > n then sol
            else if i > n then raise NotFound
                 else if safe sol i then 
                          try aux (sol@[i]) 1 (j + 1)
                          with NotFound -> aux sol (i + 1) j
                      else aux sol (i + 1) j
        in aux [] 1 1
\end{minted}
% parte da una lista vuota sol, aggiungere uno alla volta, fino ad n

\clearpage

\section{Funzioni di Ordine Superiore}

Funzioni di ordine superiore sono funzioni che prendono come argomento o restituiscono una funzione, il tipo di una funzione di ordine superiore ha più di una freccia. La funzione \verb|sum| è una funzione di ordine superiore:
\begin{minted}{ocaml}
    let rec sum f lower upper =
        if lower > upper then 0
        else f lower + sum f (lower + 1) upper
\end{minted}
Il tipo di \verb|sum| è:
\begin{minted}[mathescape, escapeinside=||]{ocaml}
     - sum: (int |$\rightarrow$| int) |$\rightarrow$| (int |$\rightarrow$| (int |$\rightarrow$| int)) 
\end{minted}
Questa funzione simula il comportamento della sommatoria, accetta come argomento una funzione di cui eseguire la somma, dati i limiti superiore ed inferiore. 

Funzioni di ordine superiore sulle liste sono la funzione di ordinamento e per iterare sui suoi elementi \verb|List.sort| e \verb|List.iter|. 
Altre funzioni importanti sono:
\begin{itemize}
    \item \verb|List.map:('a| $\rightarrow$ \verb|'b)| $\rightarrow$ \verb|'a list| $\rightarrow$ \verb|'b list|
    \item \verb|List.for_all: ('a| $\rightarrow$ \verb|bool)| $\rightarrow$ \verb|'a list| $\rightarrow$ \verb|bool|
    \item \verb|List.exists: ('a| $\rightarrow$ \verb|bool)| $\rightarrow$ \verb|'a list| $\rightarrow$ \verb|bool|
    \item \verb|List.find: ('a| $\rightarrow$ \verb|bool)| $\rightarrow$ \verb|'a list| $\rightarrow$ \verb|'a'|
    \item \verb|List.filter: ('a| $\rightarrow$ \verb|bool)| $\rightarrow$ \verb|'a list| $\rightarrow$ \verb|'a list|
\end{itemize}

La funzione \verb|map|, data una lista che gli viene passata crea una mappa associando ciascun elemento della lista $\alpha$ ad un elemento $\beta$, applicando su ognuno di essi la funzione passata, creando quindi una lista $\beta$. 
La funzione \verb|for_all| prende come parametro una lista, ed un predicato e restituisce un booleano se tutti gli elementi della lista soddisfano il predicato ricevuto in argomento. 
Analogamente \verb|exists| restituisce un booleano se esiste almeno un elemento della lista che soddisfa il predicato passato come parametro. 
La funzione \verb|find| trova e restituisce, se esiste, il primo elemento di una lista che soddisfa un predicato passato come argomento. 
Analogamente la funzione \verb|filter| restituisce tutti gli elementi della lista che soddisfano il predicato, in pratica rimuove da una lista tutti gli elementi che non soddisfano una certa condizione. Mentre se nessun elemento della lista soddisfa il predicato, solleva un'eccezione. 

Un'applicazione di \verb|map| consiste in una funzione \verb|inits| che restituisce tutti i segmenti iniziali di una lista passata come argomento:
\begin{minted}{ocaml}
    inits [1;2;3;...;n] = [[1];[1;2];...[1;2;...;n]]
\end{minted}
Si considera la sua implementazione:
\begin{minted}{ocaml}
    let rec inits = function
        | [] -> []
        | [x] -> [[x]]
        | x::xs -> [x]::(List.map ((@)[x]) (inits xs) )
\end{minted}

Si considera una funzione che produca l'insieme delle parti di un insieme, ovvero applicata ad un insieme $S$ restituisce tutti i possibili sottoinsiemi di $S$. 
Per implementare questa funzione data una rappresentazione di tipo lista $l$ dell'insieme $S$, si rimuove dalla lista il primo elemento $x$, si considera il sottoinsieme contenente solo questo elemento $[x]$, e tutti gli altri sottoinsiemi, richiamando ricorsivamente la funzione, concatenati a questo elemento $x$ rimosso. 
Non si può utilizzare l'operatore \verb|cons| infisso, quindi si utilizza l'operatore di concatenazione infisso: %% TODO why?
\begin{minted}{ocaml}
    let rec powerset = function
        | [] -> [[]]
        | x::xs -> let ps = powerset xs
                   in ps@(List.map ((@) [x]) ps)
\end{minted}
%% TODO add versione iterativa

Si determina una funzione che realizzi il prodotto cartesiano \verb|cartprod: 'a list| $\rightarrow$ \verb|'b list| $\rightarrow$ \verb|('a * 'b) list|, applicata a due insiemi \verb|setA| e \verb|setB| riporta la lista di tutte le coppie $(x,y)$ con $x\in$\verb|setA| e $y\in$\verb|setB|. Si definisce la funzione ausiliaria \verb|pair: 'a| $\rightarrow$ \verb|'b| $\rightarrow$ \verb|('a * 'b)| per poter utilizzare \verb|map|:
\begin{minted}{ocaml}
    let pair x y = (x, y);;
    let rec cartprod l1 l2 = match l1 with
        | [] -> []
        | x::xs -> (List.map (pair x) l2)@(cartprod xs l2)
\end{minted}

%% TODO aggiungere funzioni code e decode morse
Si considerano le funzioni per rappresentare e decodificare un carattere in codice morse e viceversa, utilizzando i due caratteri punto \verb|.| e linea \verb|-|. Data una lista di codici morse, si può usare la funzione \verb|map|, applicata sulla funzione di decodifica per restituire una lista di caratteri. 
%% TODO funzioni explode ed implode iterativa
Bisogna comunque passare da una lista di caratteri ad una stringa, ed in OCaml, questi due tipi non sono coincidenti quindi sono necessarie due funzioni \verb|implode char list| $\rightarrow$ \verb|string| e \verb|implode: string| $\rightarrow$ \verb|char list|. La funzione \verb|implode| si può realizzare semplicemente come:
\begin{minted}{ocaml}
    let rec implode = function
        | [] -> []
        | x::xs -> (String.make 1 x)^(implode xs)
\end{minted}
Mentre per la funzione \verb|explode| bisogna iterare su ogni elemento della stringa, e bisogna considerare l'ordine in cui verranno aggiunti gli elementi letti:
\begin{minted}{ocaml}
    let explode s = 
        let rec aux acc i x =
            if i < 0 then acc
            else aux (s.[i]::acc) (i - 1) s
        in aux [] ((String.length s) - 1) s 
\end{minted}
Se si itera partendo dall'indice iniziale, allora bisogna invertire la stringa passata alla funzione, altrimenti restituirebbe la lista corrispondente invertita. 

Altri funzioni utili nel modulo List sono:
\begin{itemize}
    \item \verb|List.rev_map: ('a| $\rightarrow$ \verb|'b)| $\rightarrow$ \verb|'a list| $\rightarrow$ \verb|'b list|, definita come la funzione \verb|map| invertita, oppure la funzione \verb|map| applicata sulla stessa lista invertita.  
    \item \verb|List.find: ('a| $\rightarrow$ \verb|bool)| $\rightarrow$ \verb|'a list| $\rightarrow$ \verb|'a|, restituire il primo elemento della lista che soddisfa il predicato.
    \item \verb|List.partition: ('a| $\rightarrow$ \verb|bool)| $\rightarrow$ \verb|'a list| $\rightarrow$ \verb|'a list * 'a list| divide la lista in un prodotto di liste, dove la prima soddisfa il predicato e la seconda non lo soddisfa. 
    \item \verb|List.fold_left: ('a| $\rightarrow$ \verb|'b| $\rightarrow$ \verb|'a)| $\rightarrow$ \verb|'a| $\rightarrow$ \verb|'b list| $\rightarrow$ \verb|'a| 
    \item \verb|List.fold_left: ('a| $\rightarrow$ \verb|'b| $\rightarrow$ \verb|'a)| $\rightarrow$ \verb|'b list| $\rightarrow$ \verb|'a| $\rightarrow$ \verb|'a|
\end{itemize}
La funzione \verb|rev_map| viene definita come:
\begin{minted}{ocaml}
    List.rev_map f lst = List.rev (List.map f lst)    
\end{minted}
Tra le più importanti di queste sono \verb|fold_left| e \verb|fold_right|. 
Queste funzioni permettono di attraversare una lista, sostituendo al costruttore della lista \verb|[]|, una certa funzione su cui viene applicata, fornendo il caso base a la lista su cui viene applicata. Questi due argomenti sono invertiti tra le due funzioni. Le due funzioni attraversano la lista in due direzioni opposte, \verb|fold_right| parte dall'inizio, mentre \verb|fold_left| parte dalla fine. Quando l'operatore di ricorsione è commutativo, utilizzare le due funzioni è equivalente. 

%% TODO add img alberi delle liste fold right 1 a sinistra, fold left 3 a destra

La funzione \verb|sumof| che somma tutti gli elementi di una lista si può quindi rappresentare come:
\begin{minted}{ocaml}
    let sumof l = List.fold_right (+) l 0;;
    let sumof l = List.fold_left (+) 0 l;;    
\end{minted}

\clearpage

\section{Definizioni di Nuovi Tipi}

Un tipo è un insieme di valori, per poter definire un nuovo tipo, è necessario un nome per il tipo e come costruire i valori del tipo, ovvero i loro costruttori. 


Si considerano i tipi enumerati, tipi costruiti da un numero finito di valori, il tipo \verb|bool| anch'esso un tipo enumerato, con solamente due possibili valori. I valori di tipi enumerati sono identificati da costanti, sono un tipo particolare di costruttori, che non richiedono alcun argomento. 

Per definire un nuovo tipo bisogna usare la parola chiave \verb|type|, seguita da un'assegnazione di valori del tipo separati da \texttt{|}, con la prima lettera maiuscola. Questi nuovi valori e tipi possono essere utilizzati per la creazione di nuovi valori e di nuovi tipi. 

\begin{minted}{ocaml}
    type direzione = Su | Giù | Destra | Sinistra
\end{minted}

% ESEMPIO rappresentazione carte napoletane

Quando viene definito un tipo enumerato, si ha l'uguaglianza, quindi è possibile utilizzare operazioni di confronto su questi tipi costruiti senza doverle definire, come \verb|List.mem|. Per recuperare il valore numerico o non di uno di questi tipi si può introdurre una funzione con il pattern matching, associando ogni valore del tipo costruito ad un valore di tipo primitivo. 


Per rappresentare la posizione ed il movimento di un oggetto su un piano bidimensionale, in una direzione oppure al cambiamento della direzione, bisogna utilizzare il nuovo tipo definito ``direzione''. La posizione di un oggetto nel piano è definita da un punto ed una direzione, quindi si considera il nuovo tipo:
\begin{minted}{ocaml}
    type posizione = int * int * direzione
\end{minted}
Questo non rappresenta un nuovo tipo, ma un'abbreviazione di tipo, ogni volta che si vuole utilizzare questa collezione di tipi già definiti. Si sta assegnando un altro nome ad un tipo già esistente. Si definiscono delle operazioni per estrarre le componenti della posizione:
\begin{minted}{ocaml}
    let pos_x (x,_,_) = x
    let pos_y (_,y,_) = y
    let pos_dir (_,_,dir) = dir    
\end{minted}


Si vogliono rappresentare due tipi di azioni, girare di $90^\circ$ in senso orario, oppure andare avanti di $n$ passi, con $n$ numero intero. Si vuole definire un tipo di dati azione per rappresentare queste azioni. Sembra che sia necessario un numero infinito di valori poiché sono presenti un numero infinito di interi, ma se si vuole realizzare un tipo enumerato, i valori devono essere finiti. Si utilizzano quindi i costruttori funzionali, che permette di rappresentare una funzione, il costruttore \verb|Avanti| restituisce il tipo azione se viene applicato su un tipo intero:
\begin{minted}{ocaml}
    type azione = Gira | Avanti of int
\end{minted}
Si utilizza la parola chiave \verb|of| per definire il costruttore funzionale. Mediante il pattern matching è possibile definire selettori di dei tipi:
\begin{minted}{ocaml}
    let int_of_act = function 
        | Avanti n -> n
        | _ -> failwith "int_of_act"
\end{minted}
Se si fosse definito il tipo posizione introducendo un nuovo tipo, con il suo costruttore, bisognerebbe modificar ele funzioni precedenti per i selettori della tripla, per essere selettori del tipo:
\begin{minted}{ocaml}
    type posizione = Pos of int * int * direzione
\end{minted}
%% TODO add selettori posizione, ... slide 

Bisogna utilizzare le parentesi altrimenti nell'uso delle funzioni, OCaml non interpreta il costruttore come applicato sugli argomenti, dato che associa a sinistra. 

La funzione di spostamento prende due argomenti, la posizione corrente e l'azione da effettuare, quello che effettua questa funzione dipende dal valore dell'azione, si dovrà calcolare i due possibili modi in cui questa funzione può comportarsi. 


La funzione gira, associata all'azione di valore \verb|Gira| è di tipo \verb|direzione| $\rightarrow$ \verb|direzione|:
\begin{minted}{ocaml}
    let gira = function
        | Su -> Destra
        | Destra -> Giù
        | Giù -> Sinistra
        | Sinistra -> Su
\end{minted}

Mentre la funzione avanti associata al valore \verb|Avanti| del tipo |azione| è di tipo \verb|posizione| $\rightarrow$ \verb|int| $\rightarrow$ \verb|posizione|:
\begin{minted}{ocaml}
    let avanti (x,y,d) n = match d with
        | Destra -> (x+n,y,d)
        | Giù -> (x,y-n,d)
        | Sinistra -> (x-n,y,d)
        | Su -> (x,y+n,d)
\end{minted}

La funzione \verb|sposta| quindi effettua un pattern matching sui due possibili valori di azione e chiama la funzione corrisponde:
\begin{minted}{ocaml}
    let sposta (x,y,d) = function
        | Gira -> (x,y,gira d)
        | Avanti n -> avanti (x,y,d) n
\end{minted}


Data la funzione sposta, definire la funzione esegui che data una posizione, ed una lista di azioni restituisce la posizione data dopo aver eseguito le azioni nell'ordine in cui sono fornite:
\begin{minted}{ocaml}
    let rec esegui pos la = List.fold_left sposta pos la
\end{minted}

% esegui (0,0,Su) [Gira; Gira];;


Si possono usare i tipi per effettuare unioni di tipi, si considera un tipo fintamente enumerato, che rappresenta l'unione del tipo intero e reale:
\begin{minted}{ocaml}
    type number = Int of int | Float of float;; 
\end{minted}
Questa rappresenta l'unione disgiunta di questi due tipi, i costruttori marcano gli elementi, rendendo riconoscibile la loro provenienza. 

Oltre ad espandere tipi si possono restringere. Si vuole creare un tipo che contenga solamente i numeri naturali, tramite la definizione induttiva dei numeri naturali bisogna indicare che $0\in\mathbb{N}$ e che data una funzione successore $\rho$, $\forall n\in\mathbb{N}\implies \rho(n)\in\mathbb{N}$. Gli unici elementi dell'insieme dei numeri naturali sono quelli ottenibili dai primi due passaggi. Si definisce ricorsivamente il tipo dei numeri naturali come:
\begin{minted}{ocaml}
    let nat = Zero | Succ of nat    
\end{minted}

%% TODO add int_of_nat

%% TODO resto del ppt
% liste in maniera polimorfa



\end{document}