\documentclass{article}

\usepackage{cancel}
\usepackage{amsmath,amssymb}
\usepackage[includehead,nomarginpar]{geometry}
\usepackage{graphicx} \usepackage{amsfonts} 
\usepackage{verbatim}
\usepackage{mathrsfs}  
\usepackage{lmodern}
\usepackage{braket}
\usepackage{bookmark}
\usepackage{fancyhdr}
\usepackage{romanbarpagenumber}
\usepackage{minted}
%\usepackage{subfig}
\usepackage[italian]{babel}
\usepackage{float}
%\usepackage{wrapfig}
%\usepackage[export]{adjustbox}
\usepackage{contour}
\usepackage[normalem]{ulem}
\allowdisplaybreaks

\setlength{\headheight}{12.0pt}
\addtolength{\topmargin}{-12.0pt}
\graphicspath{ {./Immagini/} }

\hypersetup{
    colorlinks=true,
    linkcolor=black,
    pdftitle={Appunti di Programmazione Funzionale},
    pdfauthor={Giacomo Sturm},
    pdfsubject={Programmazione Funzionale, OCaml, ML},
    pdfkeywords={Programmazione Funzionale, OCaml, ML}
}

\newsavebox{\tempbox} %{\raisebox{\dimexpr.5\ht\tempbox-.5\height\relax}}


\makeatother
\renewcommand{\contentsname}{Indice}
\numberwithin{equation}{subsection}
\newcommand{\tageq}{\tag{\stepcounter{equation}\theequation}}
\AtBeginDocument{%
    \renewcommand{\figurename}{Fig.}
}
\renewcommand{\ULdepth}{1.8pt}
\contourlength{0.6pt}
\newcommand{\myuline}[1]{%
    \uline{\phantom{#1}}%
    \llap{\contour{white}{#1}}%
}
\fancypagestyle{link}{\fancyhf{}\renewcommand{\headrulewidth}{0pt}\fancyfoot[C]{Sorgente del file \LaTeX disponibile al seguente link: \url{https://github.com/00Darxk/Programmazione-Funzionale/}}}

\begin{document}

\title{%
    \textbf{Programmazione Funzionale}  \\ 
    \large Appunti delle Lezioni di Programmazione Funzionale \\
    \textit{Anno Accademico: 2024/25}}
\author{\textit{Giacomo Sturm}}
\date{\textit{Dipartimento di Ingegneria Civile, Informatica e delle Tecnologie Aeronautiche \\
Università degli Studi ``Roma Tre"}}

\maketitle
\thispagestyle{link}

\clearpage


\pagestyle{fancy}
\fancyhead{}\fancyfoot{}
\fancyhead[C]{\textit{Programmazione Funzionale - Università degli Studi ``Roma Tre"}}
\fancyfoot[C]{\thepage}
\pagenumbering{Roman}

\tableofcontents

\clearpage
\pagenumbering{arabic}

%% 2 esoneri uno aprile uno a maggio, orale 

\section{PF01: Introduzione ad OCaml}

La programmazione funzionale è un paradigma di programmazione estremamente potente, utilizza un metodo completamente diverso dagli altri paradigmi di programmazione. L'idea di base consiste nel considerare un programma una funzione, è un linguaggio di alto livello dichiarativo. Il programmatore infatti specifica che cosa deve essere calcolato, non come deve essere calcolato, a differenza di linguaggi imperativi.  
Il linguaggio di programmazione pià funzionale è Haskell, nel corso verrà usato il linguaggio Objective Caml, contiene aspetti di programmazione orientata agli oggetti. 
%% ?? un po' bastardo
Objective Caml appartiene alla famiglia \textit{Meta Language} ML sviluppata dall'INRIA in Francia dal 1984. 
Dietro un linguaggio c'è un modello di calcolo che determina le operazioni eseguibili ed anche lo stile di programmazione. 
Si basa sul lambda calcolo, un linguaggio Turing completo, estremamente semplice. 

I tre costrutti fondamentali sono applicazioni, composizione e ricorsione. Su alcune distribuzioni di Linux l'interprete OCaml è preinstallato, ed è possibile interagirci digitando il comando \verb|ocaml| su un terminale:
\begin{minted}{ocaml}
    prompt> ocaml
    OCaml version x.x.x
    Enter #help;; for help.

    #
\end{minted}

Nella modalità interattiva il compilatore effettua il ciclo read-eval-print, legge un'espressione o una dichiarazione, terminata dalla sequenza \verb|;;|, in seguito calcola il valore, deducendo i tipi delle variabili utilizzate, e restituisce la soluzione a schermo. 
Non c'è bisogno di dichiarazioni esplicite, OCaml può effettuare inferenze di tipo anche su espressioni estremamente complesse. È un linguaggio a tipizzazione statica, ogni tipo può essere determinato a tempo di compilazione. I tipi base di OCaml sono \verb|bool|, \verb|int|, \verb|float|, \verb|string|, \verb|char|, \verb|unit| e \verb|exn|. 

\subsection{Dichiarazioni e Funzioni}

I costrutti di base sono le espressioni, non sono comandi, hanno sempre un valore ed un tipo. Il calcolo procede valutando queste espressioni, semplificandole fino ad ottenere un'espressione non più semplificabile, cioè un valore. I costruttori di controllo principale sono applicazione e composizione di funzioni e ricorsione. 

La forma generale di una dichiarazione consiste dalla parola chiave \verb|let| seguita dall'identificatore, a cui si assegna una certa espressione:
\begin{minted}{ocaml}
    let <identificatore> <parametri> = <espressione>
\end{minted}

Per specificare gli argomenti o parametri di una funzione, bisogna specificarli dopo il nome della funzione, per indicare che si tratta di una funzione ricorsiva bisogna utilizzare la parola chiave \verb|rec|, dopo \verb|let|:
\begin{minted}{ocaml}
    let rec <identificatore> <parametri> = <espressione>
\end{minted}

Le espressioni funzionali sono un particolare costrutto di espressioni introdotto dalla parola chiave \verb|function|:
\begin{minted}{ocaml}
    function <parametri> -> <espressione>
\end{minted}
Sono praticamente una funzione anonima, possono essere combinate con una dichiarazione con identificatore, avendo anch'essa un valore, per essere utilizzata all'interno della sua espressione. 

Un ambiente è una collezione di legami tra variabili e valori, l'ambiente iniziale comprende tutte queste associazioni presenti nel modulo iniziale contenuto in \verb|Stdlib|. 
Quando viene aggiunta una nuova dichiarazione viene aggiunto un nuovo legame in cima a questo ambiente. Questo ambiente viene gestito come una pila, quindi dichiarazioni future sovrascrivono dichiarazioni precedenti, poiché vengono accedute prima. 
Il valore delle variabili globali viene determinato a tempo di compilazione. Per cui è possibile modificare il valore di una variabile globale sovrascrivendola, ma altri oggetti possono comunque riferirsi alla vecchia definizione di questi valori, poiché si riferisce al tempo dove questa dichiarazione è stata inserita nell'ambiente:
\begin{minted}[escapeinside=||, mathescape]{ocaml}
    # let one = 1;;
    val one : int =  1
    # let oneplus n = n + one;;
    val oneplus : int |$\rightarrow$| int = <fun>
    # let one = 2;;
    val one = 2
    # oneplus 1;;
    - : int = 2
\end{minted}
\begin{center}
    \begin{tabular}{|c|c|}
        \hline Variabile & Valore\\\hline
        \texttt{one} & 2 \\\hline
        \texttt{oneplus} & \texttt{function n} $\to$ \texttt{n + one} \\\hline
        \texttt{one} & 1 \\\hline
        \multicolumn{2}{|c|}{\texttt{StdLib}}\\\hline
    \end{tabular}
\end{center}
Nel corpo di \texttt{oneplus} il valore di \texttt{one} viene cercato nel suo ambiente di dichiarazione, nell'ambiente dove è stata definita la funzione \texttt{oneplus}. Questo ambiente è costituito da tutti i legami precedenti nella pila. 
Quando viene applicato un argomento ad una funzione, il suo argomento viene valutato nell'ambiente, viene creato un legame provvisorio del parametro formale con il valore dell'argomento. In questo nuovo ambiente viene valutato il corpo della funzione. Dopo aver determinato il valore della funzione viene eliminato il legame provvisorio. 

Quando si effettua una definizione che non dipende dal tipo specificato dei suoi parametri, queste vengono sostituite da variabili di tipo \verb|'a|, che rappresentano un tipo generico. Per indicare che si tratta di un tipo generico viene preceduto da un'apostrofo, convenzionalmente si usano le lettere greche, $\alpha$ in questo caso. Le funzioni così dichiarate si possono applicare a parametri di qualunque tipo. 

Le funzioni sono oggetti di prima classe, hanno un proprio valore ed un tipo, quindi è possibile manipolarli, passando funzioni come argomenti ad altre funzioni. 

Nelle espressioni di tipo si associa a destra:
\begin{minted}[escapeinside=||, mathescape]{ocaml}
    int |$\rightarrow$| int |$\rightarrow$| int = int |$\rightarrow$| (int |$\rightarrow$| int)
\end{minted}
Mentre nelle espressioni si associa a sinistra:
\begin{minted}{ocaml}
    (func n) m = func n m
\end{minted}
Per cui l'uso delle parentesi è essenziale per il buon funzionamento del codice. 

Le funzioni sono oggetti di prima classe, funzioni di ordine superiore sono dei costrutti che prendono come argomento o riportano come valore una funzione. 
Funzioni possono essere componenti di una struttura dati, argomenti di altre funzioni o possono essere valori restituiti da altre funzioni. 


In questo modo si possono realizzare semplicemente funzioni come la sommatoria, che prendono come argomento la funzione \verb|f| di cui devono effettuare la somma:
\begin{minted}[escapeinside=||, mathescape]{ocaml}
    # let rec sum f (lower, upper) =
        if lower > upper then 0
        else f lower + sum f (lower + 1, upper)
    val sum : (int |$\rightarrow$| int) |$\rightarrow$| int * int |$\rightarrow$| int = <fun>
\end{minted}

La funzione \verb|sum| può essere applicata anche soltanto al suo primo argomento, generando una funzione di prima classe. Invece di inserire una coppia si possono inserire due elementi, \textit{currificando} la funzione, ovvero può funzionare anche con valutazione parziale, generando una funzione che si aspetta i rimanenti parametri, invece di generare un errore. Una funzione in forma currificata calcola gli stessi valori, consumando un solo argomento alla volta:
\begin{minted}[escapeinside=||, mathescape]{ocaml}
    # let rec sum f lower upper =
        if lower > upper then 0
        else f lower + sum f (lower + 1) upper;;
    val sum : (int |$\rightarrow$| int) |$\rightarrow$| int |$\rightarrow$| int |$\rightarrow$| int = <fun>
\end{minted}

Una funzione non currificata non può essere applicata parzialmente. 
In generale $f_c$ è la forma currificata di $f$ se:
\begin{gather*}
    f:\,t_1\times\cdots\times t_n\rightarrow t\\
    f_c:\,t_1\rightarrow(t_2\rightarrow\cdots\rightarrow(t_n\rightarrow t)\cdots)
\end{gather*}
Currificando una funzione è possibile applicarla parzialmente. 

Molte operazioni predefinite in OCaml sono in forma currificata. Le operazioni infisse predefinite sono in forma currificata, per utilizzarla in forma infissa si racchiude tra due parentesi tonde \verb|(...)|. Per definire degli operatori infissi si racchiudono tra parentesi nella loro definizione: \verb|let (...) = ...|. Questi operatori possono essere usati in forma infissa e specificando dopo gli argomenti oppure tra se prende due argomenti tra questi senza parentesi:
\begin{minted}[mathescape=true, escapeinside=||]{ocaml}
    # let (++) x y = 2 * (x + y);;
    val (++) : int |$\rightarrow$| int |$\rightarrow$| int = <fun>
    # (++) 3 5;;
    - : int 16
    # 3 ++ 5
    - : int 16
\end{minted}

Per effettuare un'operazione di composizione il codominio della seconda funzione deve essere uguale al dominio della prima funzione. Restituisce una funzione $f$ applicata su $g$: $f\circ g$, si utilizza la parola chiave \verb|comp|:
\begin{minted}{ocaml}
    let comp f g x = f (g x)
\end{minted}
La composizione è definita come un'operatore infisso \verb|(@@)|. 

\subsection{Tipi}

Un tipo è l'insieme dei valori che può assumere, i tipi predefiniti sono:
\begin{itemize}
    \item Booleani: \verb|{true, false}|, su cui sono definite le operazioni booleane \verb|not|, \verb|&&| e \texttt{||}. 
    \item Interi: \verb|{min_int,...,-1,0,1,...,max_int}|, su cui sono definite le operazioni \verb|+|, \verb|-|, \verb|*|, \verb|/|, \verb|mod|, \verb|succ| e \verb|pred|.
    \item Numeri reali a virgola mobile \verb|float|, su cui sono definite alcune delle stesse funzioni definite sugli interi, ma per mantenere l'inferenza di tipo vengono seguiti da un punto: \verb|+.|, \verb|-.|, \verb|*.| e \verb|/.|. Oltre a queste sono definite le più importanti funzioni matematiche sui reali. Non è presente la conversione automatica dei tipi numerici. 
    \item Caratteri \verb|char|, definiti sempre tra due apici \verb|'...'|, si possono convertire in codice ASCII corrispondente e viceversa con \verb|int_of_char| e \verb|char_of_int|. 
    \item Stringhe tra doppi apici \verb|"..."|, che possono essere concatenate con l'operatore di concatenazione \verb|^|, si può accedere ai singoli caratteri con la notazione puntata specificando la posizione \verb|.[i]|, la funzione \verb|string_of_int| converte un numero intero in una stringa. 
\end{itemize} 
Il tipo \verb|unit| ha un unico elemento \verb|()| e può essere usato al posto di qualsiasi tipo, si comporta come un super-tipo per tutti i tipi semplici.  

Se si utilizzano funzioni definite su interi su reali o viceversa, viene generato un errore, sono comunque presenti funzioni per convertire tra questi tipi, ma operazioni di casting vengono sconsigliate. 
Gli operatori di confronto \verb|<|, \verb|>| e \verb|=| sono definiti su qualsiasi tipo, eccetto che sulle funzioni. Nella notazione di OCaml il non uguale si rappresenta come \verb|<>|. Si possono effettuare confronti tra tuple, controllando secondo l'ordine lessicografico partendo dalla prima componente. 

\subsection{Espressioni Condizionali}

Si possono realizzare istruzioni condizionali con il costrutto \verb|if E then F else G|, dove \verb|E| è un booleano, mentre \verb|F| e \verb|G| sono espressioni dello stesso tipo o almeno un sottotipo in comune, e nei linguaggi ML deve essere possibile determinarlo a tempo di compilazione, essendo linguaggi fortemente tipati. 

Non è un costrutto di controllo come nei linguaggi imperativi, ma è un'espressione con un valore ed un tipo, il più generale tra \verb|F| e \verb|G|. Viene valutata in maniera pigra, se \verb|E| è vera, non viene valutata \verb|G|, mentre se è falsa non viene valutata \verb|F|. 

Le seguenti espressioni sono quindi equivalenti:
\begin{itemize}
    \item \verb|E && F|: \verb|if E then F else false|.
    \item \texttt{E || F}: \verb|if E then true else F|.
\end{itemize}
Il costrutto \verb|else| viene sempre indentato sotto i rispettivi \verb|if|, e deve essere presente la parte \verb|else|, non è presente ambiguità. 


Per valutare le espressioni in linguaggi ML si utilizza la regola di calcolo \textit{call by value}, la valutazione per valore, dove si calcola il valore dell'argomento prima di applicare la funzione, invece della valutazione per nome \textit{call by name}, questa regola viene utilizzata solamente nelle espressioni condizionali ed operatori booleani. La regola di calcolo per nome applica la funzione prima di aver calcolato il valore dell'argomento. 
Se non si valutassero le espressioni booleane in modo pigro, ogni funzione ricorsiva che utilizza una funzione booleana per effettuare la ricorsione, valuterebbe all'infinito il passo ricorsivo, senza poter mai fermarsi. 

\subsection{Coppie}

Le coppie ordinate sono formate da due elementi divisi da una virgola tra parentesi tonde: \verb|(E, F)|. Per rappresentare un costrutto di tipo si utilizza l'operatore \verb|*| per indicarlo, il prodotto cartesiano non è associativo. Una tupla di tuple è diversa da una tripla: \verb|int * (int * int)| \verb|<>| \verb|int * int * int|. 
Sulle coppie si utilizzano le funzioni \verb|fst| e \verb|snd| per restituire il primo ed il secondo elemento della coppia, queste sono polimorfe, ma se vengono usate su tuple di più di due elementi restituiscono un errore. 

Le coppie come tutti i tipi di dati su OCaml sono definiti da un insieme di costruttori che creano valori di quel tipo, ed un insieme di selettori, operazioni per selezionare componenti da un valore di tipo. 
I tipi semplici non hanno selettori, ma solo costruttori, questi sono tutti i valori del tipo. 
Per le coppie il costruttore è \verb|(,)|, l'insieme tra parentesi e virgola, applicato ad un'espressione di tipo $\alpha$ e $\beta$. Mentre i selettori sono \verb|fst| e \verb|snd|. 



\clearpage

\section{PF02: Ricorsione e Pattern}

\subsection{Definizioni Ricorsive}

Nei linguaggi funzionali non esistono costrutti di controllo, ma il principale meccanismo di controllo è la ricorsione, realizzato tramite la parola chiave \verb|rec|. 
In linguaggi funzionali ``puri'', non sono presenti costrutti di controllo per realizzare cicli. Per risolvere un problema ricorsivamente bisogna identificare i casi base, che possono essere risolti immediatamente. Inoltre bisogna identificare sotto-problemi più semplici di un generico problema complesso, che possono aiutare ad individuare la sua soluzione. Supponendo di poter risolvere questi problemi, l'ipotesi di lavoro, bisogna operare sulla soluzione di questi sotto-problemi per ottenere la soluzione del problema complesso. 

\subsubsection*{Esempio: \texttt{split\_string}}

Si considera il problema di valutare un'espressione aritmetica rappresentata in una stringa. L'operazione è tra due interi non negativi, la funzione offerta come soluzione dovrebbe riportare il risultato di questa espressione. Le operazioni consentite sono la somma, differenza, prodotto e divisione intera. 
Si avrà una funzione: \verb|evaluate: string -> int|. Applicata su una variabile $s$, di tipo stringa deve restituire il risultato dell'espressione rappresentata, o un errore se non rispetta le condizioni d'uso. 

Un sotto-problema utile consiste nel suddividere la stringa in tre parti, i due interi operandi ed il carattere che identifica l'operatore: \verb|split_string: string| $\rightarrow$ \verb|int * char * int|. Applicata ad una stringa $s$ restituisce una tripla $(n,op,m)$. 

Per risolvere questo problema bisogna individuare quale dei caratteri della stringa non è un numero, si può effettuare con un'altra funzione \verb|primo_non_numerico: string| $\rightarrow$ \verb|int|. Data una stringa $s$ passata come input restituisce la posizione $i$-esima del primo carattere non numerico nella stringa. 

Si può definire inoltre un'altra funzione per tagliare una porzione della stringa tra due posizioni fornite \verb|substring: string| $\rightarrow$ \verb|int| $\rightarrow$ \verb|int| $\rightarrow$ \verb|string|. Applicata ad una stringa $s$, restituisce la sotto-stringa dalla posizione $j$-esima alla posizione $k$-esima. 

Dal moduli Pervasives si può usare la funzione \verb|int_of_string| per restituire l'intero corrispondente ad una stringa. Dal modulo String, si possono usare la funzione \verb|sub| e \verb|length| per restituire una sotto-stringa la prima e la lunghezza di una stringa la seconda. 
Queste funzioni producono un errore se la stringa non corrisponde ad un intero la prima, ovvero se sono presenti caratteri non numerici, e se gli indici forniti non appartengono alla stringa, la seconda. 

Per controllare i caratteri di una stringa si usa la funzione \verb|get| del modulo String, abbreviata in notazione puntata come \verb|.[i]|. Si definisce quindi la funzione per trovare il primo carattere non numerico:
\begin{minted}{ocaml}
    let rec loop s i = 
        if (s.[i] < '0' || s.[i] > '9') then i
        else loop s (i + 1);;
    let primo_non_numerico s = loop s 0;;
\end{minted}
% primo_non_numerico "111a";;

\subsection{Dichiarazioni Locali}

All'interno di una funzione si possono dichiarare ulteriori espressioni, con il costrutto \verb|let...in|, dove si dichiara l'espressione normalmente con \verb|let|, seguito da \verb|in|, dove vengono passati i parametri da applicare all'espressione locale. Le variabili definite nella dichiarazione locale sono variabili locali, inizializzate nel \verb|in|, queste hanno un valore solamente all'interno dell'espressione locale. Quando viene valutata la funzione, questa variabile non ha più valore, viene quindi creato un legame temporanea nell'ambiente quando viene invocata quest'espressione locale tramite l'\verb|in|. All'interno di una funzione locale, sono visibili i parametri globali della funzione esterna, e possono essere usati e modificati all'interno di espressioni locali. 

Data una dichiarazione locale \verb|let x = E in F| in un ambiente $\mathscr{A}$, viene calcolato il valore \verb|v| della dichiarazione \verb|E| di \verb|let|, e viene provvisoriamente legata alla variabile \verb|x| estendendo $\mathscr{A}$. In questo nuovo ambiente viene calcolato il valore dell'espressione \verb|F| di \verb|in|. Il valore così calcolato di \verb|F| diventa il valore dell'intera espressione. Dopo averlo calcolato viene sciolto il legame provvisorio di \verb|x|, e viene ripristinato l'ambiente $\mathscr{A}$. Un'espressione locale è quindi equivalente a: \verb|let x = E in F| $\Leftrightarrow$ \verb|(function x| $\rightarrow$ \verb|F) E|. 

Si possono usare dichiarazioni locali per evitare di dover calcolare più volte il valore di un'espressione, usata più volte. 
Una funzione può essere dichiarata localmente se non ha un significato autonomo, all'esterno della funzione dove viene usata e se consente di diminuire il numero di parametri. 

\subsubsection*{Esempio: \texttt{split\_string}}

Utilizzando dichiarazioni locali è possibile inserire in una sola funzione tute le funzioni ausiliarie definite precedentemente:
\begin{minted}{ocaml}
    let primo_non_numerico s =
        let rec loop i = 
            if (s.[i] < '0' || s.[i] > '9') then i
            else loop (i+1)
        in loop 0
\end{minted}

La funzione \verb|substring| viene realizzata tramite la funzione \verb|sub| del modulo String:
\begin{minted}{ocaml}
    let substring s j k =
        String.sub s j ((k-j)+1);;    
\end{minted}

Si può quindi realizzare la funzione \verb|split_string| in questo modo:
\begin{minted}{ocaml}
    let split_string s =
        let i = primo_non_numerico s 
        in (int_of_string (substring s 0 (i - 1)),
            s.[i],
            int_of_string (substring s (i + 1) ((String.length s) - 1)))
\end{minted}

La soluzione al problema descritto, è quindi data dalla seguente funzione \verb|evaluate|:
\begin{minted}{ocaml}
    let evaluate s =
        let (n, op, m) = split_string s
        in if op = '+' then (n + m)
           else if op = '-' then (n - m)
                else if op = '*' then (n * m)
                     else if op = '/' then (n / m)
                          else ???    
\end{minted}
Si incontra un problema poiché la funzione deve restituire un risultato quando la stringa di input non rispetta le condizioni di utilizzo della funzione. Dovrebbe restituire un errore, oppure sollevare un messaggio di errore se il valore di $op$ non coincide ad uno dei quattro operatori. Il problema è che la funzione è di tipo \verb|string| $\rightarrow$ \verb|int|, quindi può solamente restituire un numero intero, anche se l'espressione aritmetica fornita non è valida per poterne calcolare il valore. 

\subsection{Eccezioni}

Si possono definire nuove eccezioni, tramite la parola chiave \verb|exception|, tutte le eccezioni sono di tipo \verb|exn|, permettono di scrivere programmi che segnalano errori. Invece di restituire un valore un'espressione può sollevare un'eccezione. Tutte le funzioni sono in grado di sollevare un'eccezione e terminare immediatamente la loro esecuzione, invece di restituire un valore. 

Esiste un insieme di eccezioni predefinite, iniziano sempre con una lettera maiuscola. Dopo che è stata dichiarata un'eccezione è anche possibile sollevarla, utilizzando la parola chiave \verb|raise|, seguita dall'identificativo dell'eccezione. 
Se durante il calcolo di un'espressione viene sollevata un'eccezione, allora il calcolo del valore termina immediatamente generando l'eccezione. Un'eccezione può essere catturata con un costrutto simile al try-catch di Java, chiamato \verb|try|-\verb|with|. Nel \verb|try| viene inserita un'espressione da calcolare, se viene sollevata un'eccezione durante il calcolo del valore, controlla se il tipo dell'eccezione sollevata corrisponde all'eccezione presente nel costrutto \verb|with|, seguito da \verb|->| che indica un'espressione da eseguire in caso sia verificata l'eccezione. Un'espressione di tipo \verb|exn| può essere il valore di qualsiasi funzione, ed argomento di qualsiasi altra funzione, questo è un eccezione per la tipizzazione forte di OCaml. Si possono usare eccezioni predefinite di OCaml per sollevare eccezioni proprie fornendo commenti più descrittivi. Il nome di tutte le eccezioni comincia con una lettera maiuscola. 

Le eccezioni vengono propagate, se durante il calcolo del valore di un'espressione \verb|E| viene sollevata un'eccezione e non viene catturata, se \verb|E| è un'espressione locale, allora l'eccezione può essere catturata all'interno dell'espressione esterna. Se non viene catturata può continuare ad essere propagata in alto fino alla prima espressione chiamante, e se non viene catturata neanche a questo punto termina l'esecuzione dell'interno programma. 

Un uso non elegante delle eccezioni consiste nell'usare un'eccezione sollevata in un costrutto \verb|try-with| per definire dei casi base per una funzione ricorsiva. In questo modo l'interruzione dell'esecuzione causata dall'eccezione restituisce il valore del caso base dal \verb|with|, mentre per gli altri casi non viene sollevata l'eccezione quindi l'esecuzione continua come se fosse stato implementato un caso base con un controllo. 

\subsubsection*{Esempio: \texttt{split\_string}}

Utilizzando un'eccezione si può risolvere il problema proposto, definendo una nuova eccezione e sollevandola se l'operatore non corrisponde a nessuno degli operatori permessi:
\begin{minted}{ocaml}
    exception BadOperation;;
    let evaluate s =
        let (n, op, m) = split_string s
        in if op = '+' then (n + m)
           else if op = '-' then (n - m)
                else if op = '*' then (n * m)
                     else if op = '/' then (n / m)
                          else raise BadOperation;;
\end{minted}

A questo punto utilizzando le eccezioni si possono inserire dei controlli nelle altre funzioni ausiliarie dentro al programma. Se non sono presenti caratteri non numerici, allora dovrebbe essere sollevata l'eccezione \verb|BadOperation|:
\begin{minted}{ocaml}
    let primo_non_numerico s =
        let rec aux i = 
            if (s.[i] < '0' || s.[i] > '9'  ) then i
            else aux (i+1)
        in try aux 0
           with Invalid_argument "index out of bounds" -> raise BadOperation
\end{minted}
L'eccezione catturata si verifica quando si esce fuori dall'indice consentito di una stringa. Si utilizza il nome \verb|aux| per indicare una funzione ausiliaria generica. 

La funzione \verb|split_string| può fallire quando viene chiamata \verb|int_of_string| se la sotto-stringa che le viene passata non corrisponde ad un intero, dato che solo il primo carattere non numerico viene rimosso, se ne è presente più di uno questo provoca il fallimento della funzione. Si può quindi definire una nuova eccezione:
\begin{minted}{ocaml}
    exception BadInt;;
    let split_string s =
        let i = primo_non_numerico s 
        in try (int_of_string (substring s 0 (i - 1)),
                s.[i],
                int_of_string (substring s (i + 1) ((String.length s) - 1)))
           with Failure "int_of_string" -> raise BadInt
\end{minted}

\subsection{Pattern}

L'uso di costrutti condizionali è molto usato e comune, e sarebbe utile per molte applicazioni poter semplificare la loro scrittura. In diversi linguaggi di programmazione sono presenti costrutti simili ad uno \textit{switch-case}, l'equivalente in OCaml e nei linguaggi ML sono i \textit{pattern}. 
Quando si effettua una dichiarazione su una variabile \verb|x|, questo è un caso particolare di pattern. 
Una dichiarazione è quindi generalmente costituita dalla parola chiave \verb|let|, seguita da un pattern, a cui viene assegnato il valore di un'espressione. 
La forza principale di OCaml consiste in questa abilità di \textit{pattern matching}. Un pattern è un'espressione costituita da variabili e/o costruttori di tipo, per i tipi introdotti fin'ora i costruttori sono tutti e soli i valori dei tipi \verb|int|, \verb|float|, \verb|bool|, \verb|char|, \verb|string| ed \verb|unit|, ed i costruttori di tuple: \verb|(,)|. In un pattern però non possono esserci ripetizioni di una stessa variabile, eccetto la variabile muta \verb|()|. 
Espressioni condizionali o contenenti operatori aritmetici non sono pattern, il pattern matching costituito da una sola variabile e qualunque espressione ha sempre esito positivo, non avendo restrizioni di alcun modo sui tipi. 

Dato un pattern \verb|P|, un certo valore \verb|V| si dice conforme al pattern \verb|P|, se è possibile sostituire le variabili in \verb|P| con il valore di sotto-espressioni di \verb|V|, in modo da ottenere \verb|V| stesso. 
Ogni espressione \verb|E| ha un suo valore \verb|V|, quindi si può generalizzare la concezione di pattern matching. 
L'operazione di pattern matching consiste nel confrontare un espressione \verb|E| con un pattern \verb|P|. Il confronto ha successo se il valore ottenuto \verb|V| è conforme al pattern \verb|P|, se ha successo allora si determina come sostituire le variabili di \verb|P| per ottenere il valore \verb|V|. Quindi viene esteso l'ambiente corrente, inserendo i legami risultanti dal pattern matching. 


Anche nelle dichiarazioni di funzioni i parametri sono pattern, permettendo di evitare l'uso di selettori all'interno del corpo della funzione. Le espressioni funzionali si scrivono allo stesso modo di una dichiarazione, utilizzando pattern. Definendo una funzione in maniera esplicita o utilizzando espressioni funzionali, il parametro può essere sempre un pattern. 

In generale quindi le espressioni \verb|function| sono della forma:
\begin{minted}{ocaml}
    function  P1 -> E1
            | P2 -> E2
            |   ...
            | Pn -> En
\end{minted}
Dove ogni pattern \verb|Pi| ha lo stesso tipo \verb|Tp| ed una sua espressione associata di stesso tipo \verb|Te|. Il tipo dell'espressione \verb|function| è quindi \verb|Tp| $\rightarrow$ \verb|Te|. Si possono anche utilizzare pattern multipli, specificando i pattern da assegnare ad una certa espressione divisi da \texttt{|}. In questo modo si possono scrivere in modo estremamente sintetico e semplice espressioni e funzioni:
\begin{minted}{ocaml}
    let F = function  P1 -> E1
                    | P2 -> E2
                    |   ...
                    | Pn -> En
\end{minted}
Per valutare questa funzione \verb|F| applicata ad un espressione \verb|E|, viene calcolato il valore dell'argomento \verb|V| e si effettua pattern matching con questo valore \verb|V|. A questo punto si effettua il processo descritto precedentemente ed il valore dell'espressione risultante dal pattern match viene riportato come il valore dell'espressione \verb|F E|, e vengono sciolti i legami provvisori. 


Si considera un espressione per il calcolo del fattoriale:
\begin{minted}{ocaml}
    let rec fact = function
          0 | 1 -> 1
        | n -> n * fact(n - 1)
\end{minted} 

L'ordine è estremamente importante, poiché dopo aver calcolato il valore dell'argomento, se il valore è applicata ad un'espressione, questo valore viene confrontato in ordine dal primo pattern in poi. Se il confronto con un pattern ha successo vengono creati legami nell'ambiente con il valore di argomento, poi viene calcolata l'espressione della funzione tramite questo valore, e vengono rimossi i legami precedentemente creati, mantenendo solamente quelli tra argomento e risultato. Quindi anche se il valore potrebbe effettuare un pattern match con pattern successivi, questo viene effettuato solamente con il primo match. 

Si può utilizzare il simbolo \verb|_| come una \textit{wildcard}, può effettuare un pattern match con qualsiasi tipo, ma non viene salvato questo legame nell'ambiente. In un costrutto try-with può essere usata per catturare qualsiasi tipo di eccezione che viene sollevata. 

Un altro costrutto con pattern matching molto utile è il match-with, questo permette di confrontare un'espressione data in input con diversi pattern dello stesso tipo dell'espressione di ingresso. Questo costrutto permette quindi di scegliere quale variabile deve essere confrontata, al contrario del costrutto per \verb|function| che prende l'argomento che gli viene passato, può essere utile in funzioni dove sono richiesti diversi argomenti. Valgono le stesse regole e condizioni generali per i pattern discusse precedentemente:
\begin{minted}{ocaml}
    match E with
          P1 -> E1
        | ...
        | Pn -> En
\end{minted}
Per valutare queste espressioni viene valutata l'espressione in input e ne viene computato il valore \verb|V|, confrontandolo con ogni \verb|P| pattern in ordine. Viene creato il legame con il primo pattern \verb|Pi| che effettua un match ed aggiunto all'ambiente. In seguito viene calcolato il valore dell'espressione \verb|Ei| corrispondente e sciolti i legami ausiliari creati. 


Si può utilizzare per definire funzioni esplicitando i parametri presi in argomento, si considera l'esempio del fattoriale:
\begin{minted}{ocaml}
    let rec fact n =
        match n with
              0 -> 1
            | _ -> n * fact(n - 1)
\end{minted}
Quando il pattern matching non è esaustivo OCaml individua il problema, ma è comunque interpreta l'espressione. Se non si riesce ad effettuare alcun un match viene sollevato un errore di tipo \verb|Match_failure|. 

\subsubsection*{Esempio: \texttt{split\_string}}

Utilizzando il pattern matching si può semplificare in modo considerevole la precedente implementazione della funzione, rimuovendo i vari costrutti condizionali annidati con un solo costrutto match:
\begin{minted}{ocaml}
    let evaluate s = 
        let (n, op, m) = split_string s
        in match op with
              '+' -> n + m
            | '-' -> n - m
            | '*' -> n * m
            | '/' -> n / m
            |  _  -> raise BadOperation    
\end{minted}

\clearpage

\section{PF03: Costrutti Imperativi e I/O}

Su OCaml nel modulo Pervasives sono presenti delle funzioni per la stampa sullo standard output \verb|stdout|, \verb|print_string| e \verb|print_int| queste funzioni sono di tipo: 
\begin{minted}[mathescape, escapeinside=||]{ocaml}
    val print_string: string |$\rightarrow$| unit
    val print_int: int |$\rightarrow$| unit
\end{minted}
Dove il tipo \verb|unit| contiene un solo elemento \verb|()|. Si vuole realizzare una funzione che permette di stampare a schermo tutti gli interi compresi tra due argomenti $n$ e $m$. 


In OCaml si può realizzare una sequenza di comandi con una notazione simile a quella di una tupla, solamente utilizzando \verb|;| al posto di virgole semplici \verb|,|:
\begin{minted}{ocaml}
    ( E1 ; E2 ; ... ; En)
\end{minted}
Se \verb|Ei| sono espressioni, allora anche questo costrutto è un'espressione formata dalla concatenazione di queste espressioni. Il tipo ed il valore di quest'espressione è dato dall'ultima espressione \verb|En|. Tutte queste espressioni vengono valutate da sinistra verso destra, ma i loro valori vengono ignorati, tranne quello dell'ultima espressione. 
Quindi si potrebbe utilizzare questo costrutto per effettuare tutte le stampe necessarie da questa funzione. 
Se sono presenti degli errori in una di queste espressioni vengono ignorati, e continua la valutazione delle espressioni successive. 

Risulta scomodo provare ad implementare la funzione richiesta utilizzando questi costrutti, poiché dovrebbe essere dinamica rispetto al numero di stampe da effettuare. Si vuole implementare iterativamente, anche se OCaml non fornisce costrutti imperativi, è possibile simulare il loro comportamento iterativo nel modo seguente:
\begin{minted}{ocaml}
    let rec ciclo n m =
        if n > m then ()
        else (print_int n;
              print_newline();
              ciclo (n + 1) m)    
\end{minted}
Questa funzione ricorsiva implementa un'iterazione poiché è \textit{tail recursive}, al ritorno della chiamata ricorsiva, non deve eseguire nulla. 

Si considera una funzione \verb|conta_digits: stringa| $\rightarrow$ \verb|int|, che restituisce il numero di caratteri numerici in una stringa $s$, realizzata in questo modo non è iterativa:
\begin{minted}{ocaml}
    let conta_digits s =
        let rec loop i =
            try if (s.[i] >= '0' && s.[i] <= '9') then 1 + loop (i + 1)
                else loop (i + 1)
            with _ -> 0
        in loop 0    
\end{minted}
Poiché la funzione \verb|loop| non è tail recursive, dato che alla fine di una ricorsione deve ancora effettuare l'operazione di addizione, sulla base del risultato del seguente passo ricorsivo \verb|1 + loop (i + 1)|. Per renderla iterativa, bisogna effettuare quest'operazione prima dell'esecuzione del seguente passo ricorsivo. Si utilizza quindi una variabile di accumulazione \verb|acc|, che ad ogni passo ricorsivo contiene il risultato del passo. In questo modo ad ogni passo ricorsivo si sono già effettuate tutte le operazioni, prima di passare al passo seguente, quindi rappresenta un algoritmo iterativo:
\begin{minted}{ocaml}
    let conta_digits s =
        let rec loop i acc =
            try if (s.[i] >= '0' && s.[i] <= '9') then loop (i + 1) (acc + 1)
                else loop (i + 1) acc
            with _ -> acc
        in loop 0 0    
\end{minted}
Questo accumulatore \verb|acc| rappresenta il risultato parziale di un'iterazione, inizializzato a zero. Questo è il modo in cui vengono realizzati algoritmi ricorsivi in OCaml, dove non sono presenti costrutti imperativi. 

Per leggere input da \verb|stdin| sempre nel modulo Pervasives sono presenti le funzioni \verb|read_line| e \verb|read_int| di tipo \verb|unit| $\rightarrow$ \verb|string| o \verb|int|. 
Si vuole realizzare una funzione che legga degli interi terminata da un punto, e ne restituisca la loro somma:
\begin{minted}{ocaml}
    let rec somma () =
        let s = read_line
        in if s="." then 0
           else (int_of_string s) + somma ()    
\end{minted}
Per realizzare lo stesso algoritmo in versione iterativa, bisogna implementare un accumulatore, in una funzione ausiliaria \verb|aux|:
\begin{minted}{ocaml}
    let somma () =
        let rec aux acc = 
            let s = read_line ()
            in if s="." then acc
               else aux ((int_of_string s) + acc)
        in aux 0
\end{minted}
La funzione ausiliaria \verb|aux| applicata su un argomento $n$ restituisce $n$ sommato agli interi letti dallo \verb|stdin|. Si possono utilizzare le eccezioni, in modo poco elegante, per rendere più sintetico questo approccio. Invece di controllare se il carattere letto è \verb|.| si può effettuare la conversione ad intero, in un try-with, e se la conversione non ha successo, allora termina l'esecuzione, poiché si suppone sia stato passato il carattere \verb|.|. Dato che il comportamento della funzione è analogo al precedente, in questo modo anche se viene inserito un carattere che non è un intero non viene terminata l'esecuzione senza output:
\begin{minted}{ocaml}
    let somma () =
        let rec aux acc =
            try let n = int_of_string (read_line ())
                in aux (n + acc)
            with _ -> acc
        in aux 0
\end{minted}

%% FIXME skipped numero_somma e numero_somma_it

Nei linguaggi iterativi non esiste l'assegnazione quindi un ciclo viene implementato da un costrutto ricorsivo. Questo è la funzione \verb|aux|, che presenta una variabile in più, l'accumulatore \verb|acc| per memorizzare il risultato parziale dell'iterazione. Gli argomenti di questa funzione sono le variabili che vengono modificate nel ciclo. L'operazione principale richiama quella ausiliaria, inizializzando l'accumulatore. In generale questa funzione ausiliaria può avere un corpo del tipo:
\begin{minted}{ocaml}
    if <condizione-uscita> then <valore-uscita>
    else <chiamata-ricorsiva> <argomenti-modificati>
\end{minted}
Gli argomenti modificati sono variabili modificate durante l'iterazione, compreso l'accumulatore. Si considera quindi una possibile implementazione iterativa dell'operazione fattoriale, precedentemente definita ricorsivamente come:
\begin{minted}{ocaml}
    let rec fact = function
          0 | 1 -> 1
        | n -> n * fact (n - 1)
\end{minted}
Iterativamente diventa:
\begin{minted}{ocaml}
    let fact' n = 
        let rec aux acc = function
              0 -> acc
            | n -> aux (n * acc) (n - 1)
        in aux 1 n
\end{minted}
Questa funzione \verb|aux| è iterativa, poiché dopo aver raccolto il risultato per un'iterazione, non deve eseguire altre operazioni. Mentre in un processo ricorsivo, dopo aver ottenuto il risultato della ricorsione bisogna effettuare altre operazioni, nel caso del fattoriale bisogna moltiplicare il valore ottenuto, il fattoriale di $n-1$, per $n$. 


Un processo ricorsivo esegue le operazioni al ritorno dalla ricorsione, mentre in un processo iterativo le operazioni vengono svolte prima della ricorsione l'ultima chiamata ricorsiva può riportare il suo risultato direttamente alla prima. Inoltre un processo ricorsivo ha uno spazio lineare al numero di chiamate ricorsive, mentre in un processo iterativo si usa spazio costante, poiché non c'è bisogno di salvare in memoria le altre chiamate ricorsive. 

Se un problema $P_1$ può essere convertito in un altro problema $P_2$ in modo che una soluzione al primo sia anche soluzione al secondo, senza siano necessari ulteriori calcoli, si dice che il problema $P_1$ è stato ridotto in $P_2$, analogamente si dice che $P_2$ è riduzione di $P_1$. Se una funzione ricorsiva è definita in modo che tutte le sue chiamate ricorsive sono delle riduzioni, allora è una funzione ricorsiva di coda, tail recursive. 

\clearpage

\section{PF04: Liste}

\subsection{Liste}

%% TODO add caratteristica di OCaml di modificare variabili con costrutti presenti in OCaml, non significa che è lecito utilizzarli essendo un corso di programmazione funzionale

Le liste sono sequenze finite di elementi dello stesso tipo, dove \verb|list| è il costruttore delle liste, preceduto dal tipo degli elementi della lista. La lista vuota è un oggetto polimorfo, indicato con \verb|[]|, di tipo \verb|'a list|. L'inserimento in testa, \textit{cons}, è un'operazione fondamentale denotata da \verb|::|, infisso. I costruttori per le liste sono:
\begin{minted}{ocaml} 
    [] : 'a list
    :: : 'a -> 'a list -> 'a list
\end{minted}
Si possono quindi realizzare liste in modo induttivo, data una lista vuota \verb|[]|, di tipo $\alpha$ \verb|list|, se \verb|x| è di tipo $\alpha$, ed \verb|xs| è di tipo $\alpha$ \verb|list|, allora \verb|(x::xs)| è una $\alpha$ \verb|list|, e nient'altro è un $\alpha$ \verb|list|. 
In questo modo è possibile generare tutte le possibili liste per un dato tipo, per stadi, realizzando un albero radicato in \verb|[]|, ed ogni figlio rappresenta l'aggiunta di un elemento del tipo tramite \verb|x::xs|, dove \verb|xs| è la lista corrispondente al nodo padre. 
%% TODO add img albero generatore liste per tipo

I selettori di una lista sono \verb|List.hd: 'a list| $\rightarrow$ \verb|'a|, \textit{head}, che restituisce il primo elemento e \verb|List.tl: 'a list| $\rightarrow$ \verb|'a list|, \textit{tail}, restituisce la lista corrispondente senza il primo elemento. Non sono definiti sulla lista vuota \verb|[]|, quindi applicati su di essa viene sollevata un'eccezione.  

Le liste possono essere costruite ricorsivamente partendo da una lista vuota \verb|[]|, supponendo di poter calcolare il valore su una lista \verb|xs|, si determina come calcolare il valore della generica lista \verb|x::xs|. 


Si vuole determinare una funzione che determina il numero degli elementi in una lista \verb|length:| \verb|'a list| $\rightarrow$ \verb|int|. Per implementarla ricorsivamente si considera una lista vuota di lunghezza 0; mentre per un caso generico, la sua lunghezza è $1+n$, dove $n$ è la lunghezza della lista rimosso il primo elemento, si suppone si possa calcolare questo valore $n$. 
La definizione è valida poiché ripetendo l'operazione di coda si arriverà necessariamente alla lista vuota \verb|[]|, la funzione è quindi definita utilizzando il selettore di coda:
\begin{minted}{ocaml}
    let rec length l = 
        if l = [] then 0
        else 1 + (length (List.tl l))
\end{minted}
Alternativamente si può utilizzare il pattern matching sulla lista:
\begin{minted}{ocaml}
    let rec length = function
          [] -> 0
        | x::xs -> 1 + (length xs)
\end{minted}
In un pattern possono occorrere solo variabili o costruttori, \verb|[]| e \verb|::|. Utilizzando questi due costruttori si può individuare il caso base di una lista vuota \verb|[]| ed il caso con una lista avente almeno un elemento \verb|x::xs|, dove a \verb|x| viene assegnato il valore del primo elemento della lista, ed a \verb|xs| viene assegnato il valore della lista rimanente. 
Questa modalità è un'alternativa all'uso dei selettori di testa e di coda per le liste. Analogamente si può effettuare pattern matching per un certo numero di elementi specifico in una lista con \verb|[x1;...x;n]|, questo pattern avrà successo solo se la lista su cui si vuole effettuare il match ha esattamente $n$ elementi ed il valore di tutti i componenti \verb|xi| assumerà il valore corrispondente dell'elemento $i-$esimo della lista. Oppure si può realizzare con \verb|x1::...::xn::xs|, dove \verb|xs| conterrà la lista vuota \verb|[]| se la lista su cui si è effettuato il match ha esattamente $n$ elementi, altrimenti sarà composta dalla coda della lista. 

\subsubsection*{Esempio: \texttt{super}}

Si vuole creare una funzione che, date le ultime $n$ estrazioni del superenalotto, restituisca i numeri che sono stati estratti meno volte. Questa funzione \verb|super| prende come parametro la lista di liste \verb|est|, rappresentanti le ultime estrazioni, il numero di interi di ogni estrazione $n$ ed il massimo numero che può essere estratto $h$:
\begin{minted}[mathescape, escapeinside=||]{ocaml}
    - super: int list list |$\rightarrow$| int |$\rightarrow$| int |$\rightarrow$| int list
    super est n h
\end{minted}
Si definisce il sotto-problema di determinare quante volte un numero $m$ compreso da 1 ad $h$ compare in tutte le estrazioni \verb|est|. Per poi iterare su tutti i possibili numeri che possono essere estratti. 
Per determinare questi numeri, si definisce la funzione \verb|upto: int| $\rightarrow$ \verb|int| $\rightarrow$ \verb|int list|, applicata sugli argomenti $i$ $j$ produce una lista da $i$ a $j$: \verb|upto i j =[i;...;j]|:
\begin{minted}{ocaml}
    let rec upto i j =
        if i > j then []
        else i::(upto (i + 1) j)    
\end{minted}

Per poter utilizzare facilmente la lista delle estrazioni, bisogna appiattirla, da una lista di liste ad una lista, quindi bisogna definire una funzione \verb|flatten:| \verb|'a list list| $\rightarrow$ \verb|'a list|:
\begin{minted}{ocaml}
    let rec flatten = function
          [] -> []
        | x::xs -> x@(flatten xs)
\end{minted}

Si definisce quindi una funzione per contare quante volte uno solo dei numeri possibili è stato estratto, che verrà applicata su tutti i possibili numeri, \verb|conta:| \verb|'a| $\rightarrow$ \verb|'a list| $\rightarrow$ \verb|int|:
\begin{minted}{ocaml}
    let rec conta x = function
          [] -> 0
        | y::ys -> if x = y then 1 + (conta x ys)
                   else conta x ys
\end{minted}

Si definisce ora una funzione per contare tutti questi possibili numeri, \verb|contatutti:| \verb|'a list| $\rightarrow$ \verb|'a list| $\rightarrow$ \verb|('a * int) list|. Il primo argomento $l_1$ è la lista contenente i possibili numeri, mentre il secondo $l_2$ è la lista contenente tutte le estrazioni. 
Questa funzione restituisce una lista di coppie, dove il primo elemento rappresenta l'elemento cercato, mentre il secondo è il suo numero di occorrenze:
\begin{minted}{ocaml}
    let rec contatutti l1 l2 = match l1 with
          [] -> []
        | x::xs -> (x, conta x l2)::(contatutti xs l2)    
\end{minted}


Utilizzando le funzioni definite si può ottenere la lista delle coppie dei possibili numeri e la loro occorrenza:
\begin{minted}{ocaml}
    contatutti (upto 1 h) (flatten est)    
\end{minted}

Per scegliere gli elementi che sono stati estratti il numero minore di volte, si può ordinare la lista, utilizzando una funzione \verb|sort:| \verb|('a * 'b) list| $\rightarrow$ \verb|('a * 'b) list|. Si può usare la funzione \verb|List.sort| fornita da OCaml nel modulo List, questa può ordinare una lista passata come parametro rispetto ad una certa relazione d'ordine espressa tramite un'espressione passata come primo argomento alla funzione. Si definisce quindi una relazione d'ordine \verb|comp:| \verb|('a * 'b)| $\rightarrow$ \verb|('c * 'b)| $\rightarrow$ \verb|int| tra due elementi, o coppie, di questa lista:
\begin{minted}{ocaml}
    let comp (_, x) (_, y) = if x < y then -1
                             else if x = y then 0
                             else 1
\end{minted}
Si definisce ora la funzione \verb|sort| come:
\begin{minted}{ocaml}
    let sort l = List.sort comp l
\end{minted}


Ottenuta la lista ordinata, per ottenere una lista dei numeri meno estratti, bisogna prima prendere un certo numero di elementi dalla lista ordinata, tramite una funzione \verb|take:| \verb|int| $\rightarrow$ \verb|'a list| $\rightarrow$ \verb|'a list|, che applicata ad un intero $n$ ed una lista $l$ restituisce una sottolista di lunghezza $n$, partendo dalla testa della lista $l$:
\begin{minted}{ocaml}
    let rec take n = function
          [] -> []
        | x::xs -> if n <= 0 then []
                   else x::(take (n - 1) xs)
\end{minted}
A questo punto non è più di interesse il numero di occorrenze, quindi si definisce una funzione \verb|primi:| \verb|('a * 'b) list| $\rightarrow$ \verb|'a list|, per restituire una lista contenete solo il primo elemento delle coppie:
\begin{minted}{ocaml}
    let rec primi = function
          [] -> []
        | (x, y)::l -> x::(primi l)
\end{minted}

Si può quindi definire la funzione \verb|super| come:
\begin{minted}{ocaml}
    let super est n h = primi (take n (sort (contatutti (upto 1 h) (flatten est))))    
\end{minted}


%% TODO fix this 15/30 PF04 ppt
%% upto: upto m n = [m, m+1, ..., n]
\begin{minted}{ocaml}
    let rec upto m n = 
        if m > n then []
        else m::(upto (m + 1) n)
\end{minted}
% versione ricorsiva: 
\begin{minted}{ocaml}
    let upto' m n =
        let rec aux l m' n' =
            if m > n then l
            else aux (n'::l) m' (n' - 1)
        in aux [] m n
\end{minted}
L'ultima riga potrebbe essere scritta come \verb|else aux (m'::l) (m'+1) n'|, ma in questo modo si inverte l'ordine della lista creata. Nelle due versioni si aggiunge sempre in testa, partendo dall'estremo superiore nel primo caso e dall'estremo inferiore nel secondo caso. 


\begin{minted}{ocaml}
    let rec take n l = match l with
          [] -> []
        | x::xs -> if n > 0 then x::(take (n - 1) xs)
                   else []
    
    let take' n l = 
        let aux acc n' l' = match l with
              [] -> acc
            | x::xs if n' > 0 then aux (acc@[x]) (n' - 1) xs
                    else acc 
        in aux [] n l
\end{minted}



\begin{minted}{ocaml}
    let rev l =
        let rec aux acc = function
              [] -> acc
            | x::xs -> aux (x::acc) xs
        in aux [] l
\end{minted}


La funzione \verb|flatten| appiattisce una lista di liste:
\begin{minted}{ocaml}
    let rec flatten ll 
        let aux acc = function 
              [] -> acc
            | x::xs -> flatten (acc@x) xs 
        in aux [] ll
\end{minted}

La funzione \verb|conta| determina le occorrenze di un elemento in una lista:
\begin{minted}{ocaml}
    let rec conta v = function
          [] -> 0
        | x::xs -> if x = v then 1 + (conta v xs)
                   else conta v xs
\end{minted}
In forma iterativa diventa:
\begin{minted}{ocaml}
    let conta v l =
        let rec aux t l' a =
            match l with
                  [] -> a
                | x::xs -> if x = t then aux t xs (a + 1)
                           else aux t xs acc
        in aux v l 0
\end{minted}
La funzione \verb|contatutti|: \verb|'a list -> 'a list -> ('a * int) list| conta tutte le occorrenze di ogni elemento nella lista \verb|flatten|:
\begin{minted}{ocaml}
    let rec contatutti e l =
        match e with
              [] -> []
            | x::xs -> (x, (conta x l))::(contatutti xs l)
\end{minted}
Per ordinarle in ordine crescente in cui sono state estratte, bisogna determinare una funzione di ordinamento per la funzione \verb|sort| del modulo \verb|List| che permette di restituire una lista di coppie in output, come in input. Si definisce una funzione ausiliaria \verb|comp|:
\begin{minted}{ocaml}
    let comp (v1, n1) = function
        (_, n) -> if n1 < n then -1
                  else if n1 = n then 0
                  else 1
\end{minted}
Questa funzione permette di comparare due coppie, quindi si può usare per ordinare una lista formata da coppie:
\begin{minted}{ocaml}
    let sort l = 
        List.sort comp l
\end{minted}


%% ??
\begin{minted}{ocaml}
    let rec primi = function
          [] -> []
        | x::xs -> (fst x)::(primi xs)
\end{minted}

\begin{minted}{ocaml}
    let super estrazioni dim higher =
        print(' (take' dim (sort (contatuttti (upto 1 higher) (flatten0 estrazioni)))))
\end{minted}

\subsubsection*{Esempio: \texttt{merge sort}}

\begin{minted}{ocaml}
    let rec split = function
          [] -> ([], [])
        | [x] -> ([x], [])
        | x::y::rest -> let (xs, ys) = split rest
                        in (x::xs, y::ys)
\end{minted}
Le due parti della lista devono avere la stessa lunghezza, o al massimo variare di uno, ci sono due casi base, se la lista è vuota o ha un sollo elemento. Se si hanno almeno due elementi si spacca a metà la lista, togliendo i primi due elementi \verb|x| e \verb|y| e si mettono in testa allo divisione successiva \verb|xs| \verb|ys|. 
Si può realizzare in modo più succinto, considerando solo due casi, una lista vuota o non vuota:
\begin{minted}{ocaml}
    let rec split = function
        | [] -> ([], [])
        | x..xs -> let (as, bs) = split xs
                    in (x::bs, as)
\end{minted}

%% FUNZIONE MERGESORT
\begin{minted}{ocaml}
    let rec mergesort = function
          [] -> []
        | [x] -> [x]
        | l -> let (l1, l2) = split l
               in merge (mergesort l1) (mergesort l2)
\end{minted}
Nel modulo list sono definite le funzioni head \verb|hd|, tail \verb|tl| già descritte in precedenza, \verb|length|, \verb|flatten| che trasforma una lista di liste in un'unica grande lista, la funzione \verb|sort| che ordina una lista, secondo un qualsiasi ordine definito da una funzione fornita come argomento. 

\clearpage

\section{PF05: Collezioni e Backtracking}


\subsection{Dizionari}

Un tipo di dato interessante sono il tipo di dato dizionario, una collezione di elementi ciascuno costituito da una coppia chiave-valore. Ogni elemento ha chiave distinta. 
Su questa collezione si può cercare un elemento per chiave, inserire una coppia di elementi, e cancellare un elemento. 
%% TODO ??
\begin{minted}{ocaml}
    let rec assoc k = function
          [] -> raise NotFound
        | (k1, v)::rest -> if k = k1 then v
                           else assoc k rest
\end{minted}
Questa dichiarazione non è corretta poiché nell'istruzione dichiarativa il tipo del costrutto \verb|then| è il tipo di \verb|v|, mentre nell'\verb|else| il tipo restituito è una funzione e non coincide ad un valore. 
Per inserire un valore in un dizionario, bisogna prima eliminare la vecchia coppia che occupava quella chiave. Essendo troppo costoso per inserire una nuova coppia questa viene inserita in testa al dizionario, mente le vecchie coppie obsolete si trovano dopo questa nuova coppia. 
\begin{minted}{ocaml}
    let rec cancella k = function
          [] -> []
        | (k', v)::rest -> if k = k' then cancella k rest
                           else  (k', v)::cancella k rest
\end{minted}


%% TODO

Rappresentare un tipo astratto di dato è costituito da un insieme di oggetti ed un insieme di operazioni su tali oggetti.  %% TODO


\subsection{Insiemi}

Negli insiemi tramite liste bisogna definire le loro operazioni. Si considera una possibile implementazione della differenza tra due insiemi:
\begin{minted}{ocaml}
    let rec setdiff l l' = function 
          [] -> 
        | x::xs -> if mem x l' then setdiff xs l'
                   else x::(setdiff xs l')
\end{minted}
In maniera iterativa:
\begin{minted}{ocaml}
    let setdiff' l l' = 
        let rec aux acc l l' = match l with
              [] -> []
            | x::xs -> if mem x l' then aux acc xs l'
                       else aux(x::acc l l')
        in aux [] l l'
\end{minted}

\subsection{Backtracking}

Il \textit{backtracking} è una delle tecniche più importanti nella progettazione di algoritmi. L'idea è di costruire una soluzione in modo incrementale, in OCaml si può realizzare semplicemente. Questo algoritmo è simile ad una ricerca in ampiezza, ma è completa, poiché dopo aver trovato tutte le soluzioni scarta quelle peggiori e mantiene la soluzione migliore. 

I candidati ad essere soluzioni sono una sequenza di elementi $x_i$ appartenenti all'insieme delle possibili soluzioni $S$. L'approccio di ``forza bruta'' considera tutte le possibili combinazioni; l'algoritmo di backtracing costruisce una sequenza $x_1,\cdots,x_i$, scegliendo ad ogni passo un nuovo elemento $x_{i+1}$ da aggiungere alla sequenza, ed analizza se questa sequenza ha possibilità di successo. Se è una soluzione mantiene la sequenza, altrimenti sceglie un altro elemento $x_{i+1}$ da aggiungere alla sequenza. 
Una condizione principale è di non poter tornare indietro per elementi già visitati, e presenti nella sequenza. Questa condizione dipende dal problema su cui viene utilizzato l'algoritmo. 


Un problema tipico dell'informatica è la somma di sottoinsiemi. dato un insieme di interi positivi $S$ ed un intero $n$, determinare un sottoinsieme di $S$: $Y\subseteq S$, tale che la somma degli elementi di $Y$ sia uguale al valore dell'intero $n$. 

Si risolve mediante il backtracking, considerando come lo spazio di ricerca delle soluzioni un albero di tutti i possibili sottoinsiemi di $S$, che rispettano la condizione della somma. Le foglie quindi possono essere delle soluzioni valide oppure sottoinsiemi non validi, quindi non è serve espanderli ulteriormente. Una volta esplorato un sotto-albero viene rimossa la sua radice e si continua la ricerca. 
%% TODO img albero sottoinsiemi ppt


Ad ogni stadio della ricerca si considerano due insiemi degli elementi visitati o da visitare, $\hat{S}$ e $\hat{\bar{S}}$, uno complementare dell'altro. All'inizio si ha che $\hat{S}=\emptyset$ è lo spazio di ricerca delle soluzioni e $\hat{\bar{S}}=S$. 
Se la somma degli elementi di $\hat{S}$ è maggiore di $n$ si ha una soluzione non valida, e si scarta l'ultimo elemento aggiunto, se è uguale ad $n$ si ha identificato una soluzione. Se la somma è minore invece ed $\hat{\bar{S}}=\emptyset$ allora non è una soluzione valida, se non è vuoto allora si sceglie un elemento $x\in\hat{\bar{S}}$, e si cerca una soluzione aggiungendo $x$ alla soluzione $\hat{S}$ con $\hat{S}\cup\{x\}$ e $\hat{\bar{S}}\setminus\{x\}$ oppure senza aggiungerlo alla soluzione con $\hat{S}$ e $\hat{\bar{S}\setminus\{x\}}$ 

Per implementare un algoritmo risolutivo di questo problema si considera una funzione ausiliaria \verb|sum'| che somma tutti gli elementi di una lista:
\begin{minted}{ocaml}
    let sum' l =
        let rec aux tot = function
              [] -> tot
            | x::xs -> aux(tot+x) xs
        in aux 0 l
\end{minted}

Si definisce un'eccezione \verb|NotFound| in caso la soluzione individuata non rappresenta una soluzione del problema:
\begin{minted}{ocaml}
    exception NotFound
\end{minted}
Si implementa ora l'algoritmo:
\begin{minted}{ocaml}
    let search_subset set tot = 
        let rec search_aux solution others tot' =
            let s = sum' solution
            in if s= tot' then solution
               else if s > tot' then raise NotFound
               else match others with
                     [] -> raise NotFound
                   | x::xs -> try search_aux (x::solution) xs tot
                              with NotFound -> search_aux solution xs tot
        in search_aux [] set tot
\end{minted}

%% TEST search_subset [5;4;6;8;3;53;7;0;24;9] 15


Per creare una versione generale che restituisce tutte le possibili soluzioni, si creano delle funzioni ausiliarie:
\begin{minted}{ocaml}
    let rec mapcons a = function
          [] -> []
        | l::ls -> (a::l) :: (mapcons a ls)
\end{minted}

In questo modo si può definire la funzione \verb|search_all| che cerca tutte le possibili soluzioni:
\begin{minted}{ocaml}
    let rec search_all tot = function
          [] -> if tot > 0 then []
                else [[]] 
        | x::xs -> if x > tot then serach_all tot xs
                   else mapcons 
\end{minted}
%% TODO finire

\subsubsection{Problema delle 8 Regine}

Un problema comune chiamato problema delle 8 regine, consiste nell'individuare su una scacchiare una configurazione di otto regine, in modo che non siano mai sotto attacco. Poiché le regine possono attaccare su l'intera riga e colonna dove sono disposte, un modo per semplificare il problema, consiste nel posizionare le regine in tutte le righe e colonne, senza avere più regine sulla stessa riga e colonna, altrimenti sarebbero sicuramente sotto attacco. 
Il problema quindi consiste nel trovare una configurazione di otto regine, dove le diagonali non incontrano mai altre regine. 
Utilizzando il metodo della soluzione incrementale consiste nel piazzare una regina su una casella, e controllare se mettendo le restanti regine si trova una soluzione valida, altrimenti si ritorna a questa posizione iniziale e si sceglie un'altra casella. 

Scomponendo il problema in sotto-problemi è sicuramente necessario avere una funzione che indica se una regina è sotto attacco. Questa funzione deve avere come parametri due posizioni, quindi due coppie di interi, e deve restituire un booleano se queste due posizione, contenessero delle regine, sarebbero sotto attacco l'una rispetto all'altra. Anche se non si tratta di uno scacco, è più intuitivo parlare di scacco, piuttosto di attacco, per indicare che la soluzione non è valida. 
Date due coppie di interi $i,j$ e $m,n$ se le due regine sono sulla stessa diagonale ascendente, allora la distanza attraversata in diagonale deve essere uguale, questa distanza si ottiene sommando le due coordinate. Mentre per determinare se sono sulla stessa diagonale discendente bisogna controllare che scendendo dalle coordinate $i$, $j$ a $i-m$ e $j-n$ ci si trova nella stessa diagonale. 
Mentre sono sicuramente sotto attacco se la colonna o la riga è uguale. 
\begin{minted}{ocaml}
    let scacco ( i, j ) ( m, n ) =
        i = m || ( i - m = j - n) || ( i + j = m + n ) || j = n
\end{minted}


Poiché su ogni colonna può esserci una sola colonna, una regina viene individuata in maniera univoca solamente dalla sua colonna. Per sapere su quale riga si trova, si considera una lista, dove l'indica su quale riga si trova, mentre il valore contenuto è variabile ed indica la colonna su cui si trova attualmente nella scacchiera. Quindi la riga delle regine è sempre fissata, mentre possono traslare sulle colonne:
\begin{minted}{ocaml}
    let board = [1;2;3;4;5;6;7;8]
\end{minted}
% soluzione corretta:
% let board = [6;3;1;8;5;2;4;7]
In questa rappresentazione, quindi non è necessaria la condizione per il controllo sulla riga:
\begin{minted}{ocaml}
    let scacco (i, j) (m, n) =
        i = m || (i - m = j - n) || (i + j = m + n)
\end{minted}
Per evitare di accedere alla lista per ottenere l'indice si può realizzare direttamente una lista di coppie. Per passare a questa rappresentazione si crea una funzione ausiliaria:
\begin{minted}{ocaml}
    let combine l = 
        let rec aux n acc = function
              [] -> acc
            | x::xs -> aux (n + 1) ((x,n)::acc) xs
        in List.rev(aux 1 [] l)
\end{minted}
Si crea quindi una funzione \verb|safe| che controlla data una configurazione della scacchiera, se una certa riga $m$ è libera. %% ??
Questa funzione prova ad aggiungere una regina alla riga $m$, se non sono presenti regine sulla scacchiera allora si può aggiungere senza problemi, altrimenti bisogna controllare se si può posizionare su una delle colonne della riga $m$, senza che sia sotto attacco. Se ciò non è possibile allora restituisce falso. 
% let board = [1;1;1]
% safe board 1
% \begin{minted}{ocaml}
%     let safe board m =
%         let c = List.length board + 1 in 
%         let rec aux n = function
%               [] -> false
%             | x::xs -> scacco (x, n) (m, c) || aux (n + 1) xs
%         in not (aux 1 board)    
% \end{minted}
\begin{minted}{ocaml}
    let safe board m =
        let n = List.length board
        in let rec aux = function
              [] -> true
            | (i, j)::xs -> not (scacco (i, j) (m, n + 1)) && aux xs
        in aux (combine board)    
\end{minted}

Il problema ora consiste nell'utilizzare questa funzione \verb|safe| per trovare una soluzione al problema. Si definisce un'eccezione \verb|NotFound| in caso non si è trovata una soluzione: 
\begin{minted}{ocaml}
    exception NotFound;;
    let queens n = 
        let rec aux sol i j = 
            if j > n then sol
            else if i > n then raise NotFound
                 else if safe sol i then 
                          try aux (sol@[i]) 1 (j + 1)
                          with NotFound -> aux sol (i + 1) j
                      else aux sol (i + 1) j
        in aux [] 1 1
\end{minted}
% parte da una lista vuota sol, aggiungere uno alla volta, fino ad n

\clearpage

\section{Funzioni di Ordine Superiore}

Funzioni di ordine superiore sono funzioni che prendono come argomento o restituiscono una funzione, il tipo di una funzione di ordine di una funzione ha più di una freccia. La funzione \verb|sum| è una funzione di ordine superiore:
\begin{minted}{ocaml}
    let rec sum f lower upper =
        if lower > upper then 0
        else f lower + sum f (lower + 1) upper
\end{minted}
Il tipo di \verb|sum| è:
\begin{minted}[mathescape, escapeinside=||]{ocaml}
     - sum: (int |$\rightarrow$| int) |$\rightarrow$| (int |$\rightarrow$| (int |$\rightarrow$| int)) 
\end{minted}
Questa funzione simula il comportamento della sommatoria, accetta come argomento una funzione di cui eseguire la somma, dati i limiti superiore ed inferiore. 

Funzioni di ordine superiore sulle liste sono la funzione di ordinamento e per iterare sui suoi elementi \verb|List.sort| e \verb|List.iter|. 
Altre funzioni importanti sono:
\begin{itemize}
    \item \verb|List.map:('a| $\rightarrow$ \verb|'b)| $\rightarrow$ \verb|'a list| $\rightarrow$ \verb|'b list|
    \item \verb|List.for_all: ('a| $\rightarrow$ \verb|bool)| $\rightarrow$ \verb|'a list| $\rightarrow$ \verb|bool|
    \item \verb|List.exists: ('a| $\rightarrow$ \verb|bool)| $\rightarrow$ \verb|'a list| $\rightarrow$ \verb|bool|
    \item \verb|List.find: ('a| $\rightarrow$ \verb|bool)| $\rightarrow$ \verb|'a list| $\rightarrow$ \verb|'a'|
    \item \verb|List.filter: ('a| $\rightarrow$ \verb|bool)| $\rightarrow$ \verb|'a list| $\rightarrow$ \verb|'a list|
\end{itemize}

La funzione \verb|map|, data una lista che gli viene passata crea una mappa associando ciascun elemento della lista $\alpha$ ad un elemento $\beta$, applicando su ognuno di essi la funzione passata, creando quindi una lista $\beta$. 
La funzione \verb|for_all| prende come parametro una lista, ed un predicato e restituisce un booleano se tutti gli elementi della lista soddisfano il predicato ricevuto in argomento. 
Analogamente \verb|exists| restituisce un booleano se esiste almeno un elemento della lista che soddisfa il predicato passato come parametro. 
La funzione \verb|find| trova e restituisce, se esiste, il primo elemento di una lista che soddisfa un predicato passato come argomento. 
Analogamente la funzione \verb|filter| restituisce tutti gli elementi della lista che soddisfano il predicato, in pratica rimuove da una lista tutti gli elementi che non soddisfano una certa condizione. Mentre se nessun elemento della lista soddisfa il predicato, solleva un'eccezione. 

Un'applicazione di \verb|map| consiste in una funzione \verb|inits| che restituisce tutti i segmenti iniziali di una lista passata come argomento:
\begin{minted}{ocaml}
    inits [1;2;3;...;n] = [[1];[1;2];...[1;2;...;n]]
\end{minted}
Si considera la sua implementazione:
\begin{minted}{ocaml}
    let rec inits = function
          [] -> []
        | [x] -> [[x]]
        | x::xs -> [x]::(List.map ((@)[x]) (inits xs) )
\end{minted}

\subsubsection*{Esercizi}

Si definisca la funzione \verb|find|, definita nel modulo List, tale che \verb|find p lst| restituisca il primo elemento della lista \verb|lst| che soddisfa il predicato \verb|p|, altrimenti solleva un'eccezione. 
\begin{minted}{ocaml}
    exception NotFound;;
    let rec find p = function
          [] -> raise NotFound
        | x::xs -> if (p x) then x
                   else find p xs
\end{minted}

Si definisce la funzione \verb|takeawhile p lst| che riporti la più lunga parte iniziale di \verb|lst| costituita da tutti gli elementi che soddisfano il predicato \verb|p|. 
\begin{minted}{ocaml}
    let rec takeawhile p = function
          [] -> []
        | x::xs -> if (p x) then x::(takeawhile p xs)
                   else []
\end{minted}
Definire ora un predicato \verb|p|, tale che la funzione \verb|takeawhile| restituisca la parte iniziale contenente solo numeri pari:
\begin{minted}{ocaml}
    takeawhile (function x -> x mod 2 = 0) l    
\end{minted}

Si definisca la funzione \verb|partition: ('a| $\rightarrow$ \verb|bool)| $\rightarrow$ \verb|'a list| $\rightarrow$ \verb|('a list * 'a list)|, tale che applicata ad un predicato \verb|p| ed una lista \verb|lst| restituisca una coppia di liste, dove la prima contiene tutti gli elementi che soddisfano il predicato, mentre la seconda lista contiene tutti gli elementi che non lo soddisfano:
\begin{minted}{ocaml}
    let partition p l =
        let rec aux (yes, no) = function
              [] -> (yes, no)
            | x::xs -> if (p x) then aux ((yes@[x]), no) xs
                       else aux (yes, (no@[x])) xs
        in aux ([], []) l    
\end{minted}

Definire la funzione \verb|pairwith|, che dato un elemento ed una lista restituisce una lista di coppie formate dall'elemento passato e l'elemento corrispondente della lista passata, utilizzando \verb|List.map|
\begin{minted}{ocaml}
    let pairwith x l = List.map (function y -> (x, y) ) l
\end{minted}

Definire la funzione \verb|setdiff| per la differenza insiemistica, utilizzando \verb|List.filter|:
% \begin{minted}{ocaml}
%     let rec isin l x = match l with
%           [] -> true
%         | y::ys -> if (x = y) then false
%                    else isin ys x;;
%     let setdiff l1 l2 = List.filter (isin l2) l1
% \end{minted}

\begin{minted}{ocaml}
    let mem l x = List.exists ((=) x) l;;
    let setdiff l1 l2 = List.filter (not (mem l2)) l1
\end{minted}

Un'altra soluzione possibile è la seguente:
\begin{minted}{ocaml}
    list rec setdiff l1 = function
          [] -> l1
        | x::xs -> setdiff(List.fiter (function x -> x <> n) l1) xs    
\end{minted}

%% TODO esempio powerset
\begin{minted}{ocaml}
    let rec powerset = function
          [] -> [[]]
        | x::xs -> []::[[x]]::(List.map ((@) [x]) (powerset xs))
\end{minted}

\clearpage

\section{Esercitazione 2}

%% TODO add esercitazione n. 1

Definire una funzione \verb|ultime_cifre:| \verb|-> int * int| che riporti il valore intero delle due ultime cifre di un \verb|int|. Dato un numero, il suo modulo base 10 restituisce l'ultima cifra. Mentre per ottenere la penultima si effettua una divisione intera per 10 per eliminare l'ultima cifra e si riapplica il modulo base 10 per ottenere questa cifra:
\begin{minted}{ocaml}
    let ultime_cifre x = (abs(x) mod 10, abs(x/10) mod 10);;
\end{minted}

%% TODO esercitazione 17/3/25

Una cifra è bella se è 0, 3 o 7; un numero è bello se la sua ultima cifra è bella e la penultima (se esiste) non lo è. Definire un predicato \verb|bello: int -> bool|, che determini se un numero è bello, la funzione non deve mai sollevare eccezioni, ma riportare sempre un \verb|bool|. 
\begin{minted}{ocaml}
    let bello x = 
        match abs(x mod 10) with
            0 | 3 | 7 -> (match (abs(x mod 10))/10 with
                0 | 3 | 7 -> x < 10
                    3 | 7 -> false
                    | 0 -> x < 100
                    | _ -> true)
            | _ -> false;;
\end{minted}

Scrivere una funzione \verb|data: int * string -> bool|, che applicata ad una coppia \verb|(d, m)| di un intero \verb|d| e una stringa \verb|m|, determini se la coppia rappresenta una data corretta, assumendo che l'anno non sia bisestile, si assuma che i mesi siano rappresentati da stringhe con caratteri minuscoli. La funzione on deve sollevare eccezioni, ma riportare sempre un \verb|bool|. 
È utile scrivere una funzione \verb|gdm| per determinare i giorni di un mese:
\begin{minted}{ocaml}
    let gdm m = 
        match with
        "gennaio"  | "marzo" | "maggio" | "luglio" | "agosto" | "ottobre" | "dicembre" -> 31
        | "aprile" | "giugno" | "settembre" | "novembre" -> 30
        | "febbraio" -> 28
        | _ -> 0
\end{minted}
La funzione principale è quindi:
\begin{minted}{ocaml}
    let data (d,m) = d <= gdm m && d > 0;;
\end{minted}

\clearpage

\section{Esercitazione 3}

\begin{minted}{ocaml}
    exception NoElement ;; 
    let maxlist = function
          [] -> raise NoElement
        | x::xs -> let rec aux m = function
              [] -> m
            | x::xs -> if x > m then aux x xs
                       else aux m xs
            in aux x xs
\end{minted}

Si ipotizza di non avere a disposizione l'operatore \verb|@|, definire la concatenazione:
\begin{minted}{ocaml}
    let rec append l1 l2 = match l1 with
          [] -> l2
        | x::xs -> x::(append xs l2) 
\end{minted}
In modo iterativo diventa:
\begin{minted}{ocaml}
    let append l1 l2 =
        let rec aux a = function
              [] -> a
            | x::xs -> aux (x::a) xs
        in aux l2 List.rev(l1)
\end{minted}


\begin{minted}{ocaml}
    let rec nth n = function
          [] -> raise NoElement
        | x::xs -> if n < 0 then raise NoElement
                   else if n = 0 then x
                        else nth (n-1) xs;;
\end{minted}


\begin{minted}{ocaml}
    let rec nondec = function
          [] | [a] -> true
        | x::y::xs -> if x > y then false
                      else nondec (y::xs)
\end{minted}


%% TODO idfk 

\begin{minted}{ocaml}
    let min_dei_max ls = 
        let rec listmax acc = function
              [] -> acc
            | x::xs -> listmax ((maxlist x)::acc) xs
        in let rec minlist = function
              [] -> raise NoElement
            | x::xs -> try let y = minlist(xs)
                           in min x y
                       with _ -> x
        in minlist(listmax [] ls);;
\end{minted}
%% TESTING funzione con ocaml repl
% min_dei_max [[1;2;3];[3;4;1;0];[78]];;

Concatena l'accumulatore con i massimi di ciascuna lista del secondo argomento, l'argomento implicito è una lista di liste, essendo l'argomento della funzione esterna \verb|ls|. Si può inferire il tipo dato che ad un elemento della lista \verb|x| viene passato come argomento a \verb|maxlist|, quindi deve essere una lista. 



\verb|split2| agisce in modo simile alla funzione \verb|split| definita precedentemente, divide in due parti ...

\clearpage


\end{document}